/*
 * Copyright Â© 2019 Splunk, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"): you may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * Metadata Catalog
 *
 * With the Metadata Catalog you can create and manage knowledge objects such as datasets, fields, rules, actions, dashboards, and workflows.
 *
 * API version: v2beta1.1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.
 */

package catalog

import (
	"net/http"

	"github.com/splunk/splunk-cloud-sdk-go/services"
	"github.com/splunk/splunk-cloud-sdk-go/util"
)

const serviceCluster = "api"

type Service services.BaseService

// NewService creates a new catalog service client from the given Config
func NewService(config *services.Config) (*Service, error) {
	baseClient, err := services.NewClient(config)
	if err != nil {
		return nil, err
	}
	return &Service{Client: baseClient}, nil
}

/*
	CreateActionForRule - catalog service endpoint
	Create a new action for a rule associated with a specific resource name.
	Parameters:
		ruleresourcename: The resource name of a rule. For the default module, the resource name format is ruleName. Otherwise, the resource name format is module.ruleName.
		actionPost: The JSON representation of the action to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateActionForRule(ruleresourcename string, actionPost ActionPost, resp ...*http.Response) (*Action, error) {
	pp := struct {
		Ruleresourcename string
	}{
		Ruleresourcename: ruleresourcename,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/rules/{{.Ruleresourcename}}/actions`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: actionPost})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb Action
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CreateActionForRuleById - catalog service endpoint
	Create a new action for a specific rule.
	Parameters:
		ruleid: ID of a Field.
		actionPost: The JSON representation of the action to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateActionForRuleById(ruleid string, actionPost ActionPost, resp ...*http.Response) (*Action, error) {
	pp := struct {
		Ruleid string
	}{
		Ruleid: ruleid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/rules/{{.Ruleid}}/actions`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: actionPost})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb Action
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CreateAnnotationForDatasetById - catalog service endpoint
	Create a new annotation for a specific dataset.
	Parameters:
		datasetid: ID of a Dataset.
		annotationPost: The JSON representation of the annotation to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateAnnotationForDatasetById(datasetid string, annotationPost AnnotationPost, resp ...*http.Response) (*Annotation, error) {
	pp := struct {
		Datasetid string
	}{
		Datasetid: datasetid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetid}}/annotations`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: annotationPost})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb Annotation
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CreateAnnotationForDatasetByResourceName - catalog service endpoint
	Create a new annotation for a specific dataset.
	Parameters:
		datasetresourcename: The resource name of a dataset. For the default module, the resource name format is datasetName. Otherwise, the resource name format is module.datasetName.
		annotationPost: The JSON representation of the annotation to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateAnnotationForDatasetByResourceName(datasetresourcename string, annotationPost AnnotationPost, resp ...*http.Response) (*Annotation, error) {
	pp := struct {
		Datasetresourcename string
	}{
		Datasetresourcename: datasetresourcename,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetresourcename}}/annotations`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: annotationPost})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb Annotation
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CreateDashboard - catalog service endpoint
	Create a new dashboard.
	Parameters:
		dashboardPost: The JSON representation of the Dashboard to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateDashboard(dashboardPost DashboardPost, resp ...*http.Response) (*Dashboard, error) {
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/dashboards`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: dashboardPost})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb Dashboard
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CreateDataset - catalog service endpoint
	Create a new dataset.
	Parameters:
		datasetPost: JSON representation of the DatasetInfo to be persisted
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateDataset(datasetPost DatasetPost, resp ...*http.Response) (*Dataset, error) {
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: datasetPost})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb Dataset
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CreateDatasetImport - catalog service endpoint
	Create a new dataset import.
	Parameters:
		datasetresourcename: The resource name of a dataset. For the default module, the resource name format is datasetName. Otherwise, the resource name format is module.datasetName.
		datasetImportedBy
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateDatasetImport(datasetresourcename string, datasetImportedBy DatasetImportedBy, resp ...*http.Response) (*ImportDataset, error) {
	pp := struct {
		Datasetresourcename string
	}{
		Datasetresourcename: datasetresourcename,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetresourcename}}/importedby`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: datasetImportedBy})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb ImportDataset
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CreateDatasetImportById - catalog service endpoint
	Create a new dataset import.
	Parameters:
		datasetid: ID of a Dataset.
		datasetImportedBy
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateDatasetImportById(datasetid string, datasetImportedBy DatasetImportedBy, resp ...*http.Response) (*ImportDataset, error) {
	pp := struct {
		Datasetid string
	}{
		Datasetid: datasetid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetid}}/importedby`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: datasetImportedBy})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb ImportDataset
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CreateFieldForDataset - catalog service endpoint
	Create a new field on a specific dataset.
	Parameters:
		datasetresourcename: The resource name of a dataset. For the default module, the resource name format is datasetName. Otherwise, the resource name format is module.datasetName.
		fieldPost: The JSON representation of the field to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateFieldForDataset(datasetresourcename string, fieldPost FieldPost, resp ...*http.Response) (*Field, error) {
	pp := struct {
		Datasetresourcename string
	}{
		Datasetresourcename: datasetresourcename,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetresourcename}}/fields`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: fieldPost})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb Field
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CreateFieldForDatasetById - catalog service endpoint
	Add a new field to a dataset.
	Parameters:
		datasetid: ID of a Dataset.
		fieldPost: The JSON representation of the field to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateFieldForDatasetById(datasetid string, fieldPost FieldPost, resp ...*http.Response) (*Field, error) {
	pp := struct {
		Datasetid string
	}{
		Datasetid: datasetid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetid}}/fields`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: fieldPost})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb Field
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CreateRelationship - catalog service endpoint
	Create a new relationship.
	Parameters:
		relationshipPost: The JSON representation of the relationship to persist.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateRelationship(relationshipPost RelationshipPost, resp ...*http.Response) (*Relationship, error) {
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/relationships`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: relationshipPost})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb Relationship
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CreateRule - catalog service endpoint
	Create a new rule.
	Parameters:
		rulePost: The JSON representation of the rule to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateRule(rulePost RulePost, resp ...*http.Response) (*Rule, error) {
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/rules`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: rulePost})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb Rule
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CreateWorkflow - catalog service endpoint
	Create a new workflow configuration.
	Parameters:
		workflowPost: The JSON representation of the workflow to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateWorkflow(workflowPost WorkflowPost, resp ...*http.Response) (*Workflow, error) {
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/workflows`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: workflowPost})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb Workflow
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CreateWorkflowBuild - catalog service endpoint
	Create a new workflow build.
	Parameters:
		workflowid: ID of a workflow.
		workflowBuildPost: The JSON representation of the workflow build to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateWorkflowBuild(workflowid string, workflowBuildPost WorkflowBuildPost, resp ...*http.Response) (*WorkflowBuild, error) {
	pp := struct {
		Workflowid string
	}{
		Workflowid: workflowid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/workflows/{{.Workflowid}}/builds`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: workflowBuildPost})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb WorkflowBuild
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CreateWorkflowRun - catalog service endpoint
	Create a new workflow run for the specified workflow build ID.
	Parameters:
		workflowid: ID of a workflow.
		workflowbuildid: ID of a workflow build.
		workflowRunPost: The JSON representation of the workflow run to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateWorkflowRun(workflowid string, workflowbuildid string, workflowRunPost WorkflowRunPost, resp ...*http.Response) (*WorkflowRun, error) {
	pp := struct {
		Workflowid      string
		Workflowbuildid string
	}{
		Workflowid:      workflowid,
		Workflowbuildid: workflowbuildid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/workflows/{{.Workflowid}}/builds/{{.Workflowbuildid}}/runs`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: workflowRunPost})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb WorkflowRun
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	DeleteActionByIdForRule - catalog service endpoint
	Delete an action on a rule.
	Parameters:
		ruleresourcename: The resource name of a rule. For the default module, the resource name format is ruleName. Otherwise, the resource name format is module.ruleName.
		actionid: ID of an Action.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteActionByIdForRule(ruleresourcename string, actionid string, resp ...*http.Response) error {
	pp := struct {
		Ruleresourcename string
		Actionid         string
	}{
		Ruleresourcename: ruleresourcename,
		Actionid:         actionid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/rules/{{.Ruleresourcename}}/actions/{{.Actionid}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	return err
}

/*
	DeleteActionByIdForRuleById - catalog service endpoint
	Delete an action that is part of a specific rule.
	Parameters:
		ruleid: ID of a Field.
		actionid: ID of an Action.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteActionByIdForRuleById(ruleid string, actionid string, resp ...*http.Response) error {
	pp := struct {
		Ruleid   string
		Actionid string
	}{
		Ruleid:   ruleid,
		Actionid: actionid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/rules/{{.Ruleid}}/actions/{{.Actionid}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	return err
}

/*
	DeleteAnnotationOfDatasetById - catalog service endpoint
	Delete a specific annotation of a dataset.
	Parameters:
		datasetid: ID of a Dataset.
		annotationid: ID of a annotation.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteAnnotationOfDatasetById(datasetid string, annotationid string, resp ...*http.Response) error {
	pp := struct {
		Datasetid    string
		Annotationid string
	}{
		Datasetid:    datasetid,
		Annotationid: annotationid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetid}}/annotations/{{.Annotationid}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	return err
}

/*
	DeleteAnnotationOfDatasetByResourceName - catalog service endpoint
	Delete a specific annotation of a dataset.
	Parameters:
		datasetresourcename: The resource name of a dataset. For the default module, the resource name format is datasetName. Otherwise, the resource name format is module.datasetName.
		annotationid: ID of a annotation.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteAnnotationOfDatasetByResourceName(datasetresourcename string, annotationid string, resp ...*http.Response) error {
	pp := struct {
		Datasetresourcename string
		Annotationid        string
	}{
		Datasetresourcename: datasetresourcename,
		Annotationid:        annotationid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetresourcename}}/annotations/{{.Annotationid}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	return err
}

/*
	DeleteDashboardById - catalog service endpoint
	Delete the dashboard with the specified ID.
	Parameters:
		dashboardid: ID of a dashboard.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteDashboardById(dashboardid string, resp ...*http.Response) error {
	pp := struct {
		Dashboardid string
	}{
		Dashboardid: dashboardid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/dashboards/{{.Dashboardid}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	return err
}

/*
	DeleteDashboardByResourceName - catalog service endpoint
	Delete the dashboard with the specified resource name.
	Parameters:
		dashboardresourcename: The resource name of a dashvboard. The resource name format is module.dashboardname.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteDashboardByResourceName(dashboardresourcename string, resp ...*http.Response) error {
	pp := struct {
		Dashboardresourcename string
	}{
		Dashboardresourcename: dashboardresourcename,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/dashboards/{{.Dashboardresourcename}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	return err
}

/*
	DeleteDataset - catalog service endpoint
	Delete the dataset with the specified resource name, along with its dependencies. For the default module, the resource name format is datasetName. Otherwise, the resource name format is module.datasetName.
	Parameters:
		datasetresourcename: The resource name of a dataset. For the default module, the resource name format is datasetName. Otherwise, the resource name format is module.datasetName.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteDataset(datasetresourcename string, resp ...*http.Response) error {
	pp := struct {
		Datasetresourcename string
	}{
		Datasetresourcename: datasetresourcename,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetresourcename}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	return err
}

/*
	DeleteDatasetById - catalog service endpoint
	Delete a specific dataset. Deleting a dataset also deletes its dependent objects, such as fields.
	Parameters:
		datasetid: ID of a Dataset.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteDatasetById(datasetid string, resp ...*http.Response) error {
	pp := struct {
		Datasetid string
	}{
		Datasetid: datasetid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetid}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	return err
}

/*
	DeleteFieldByIdForDataset - catalog service endpoint
	Delete a field that is part of a specific dataset.
	Parameters:
		datasetresourcename: The resource name of a dataset. For the default module, the resource name format is datasetName. Otherwise, the resource name format is module.datasetName.
		fieldid: ID of a Field.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteFieldByIdForDataset(datasetresourcename string, fieldid string, resp ...*http.Response) error {
	pp := struct {
		Datasetresourcename string
		Fieldid             string
	}{
		Datasetresourcename: datasetresourcename,
		Fieldid:             fieldid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetresourcename}}/fields/{{.Fieldid}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	return err
}

/*
	DeleteFieldByIdForDatasetById - catalog service endpoint
	Delete a field that is part of a specific dataset.
	Parameters:
		datasetid: ID of a Dataset.
		fieldid: ID of a Field.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteFieldByIdForDatasetById(datasetid string, fieldid string, resp ...*http.Response) error {
	pp := struct {
		Datasetid string
		Fieldid   string
	}{
		Datasetid: datasetid,
		Fieldid:   fieldid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetid}}/fields/{{.Fieldid}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	return err
}

/*
	DeleteRelationshipById - catalog service endpoint
	Delete a specific relationship. Deleting a relationship also deleletes any objects that are dependents of that relationship, such as relationship fields.
	Parameters:
		relationshipid: ID of a relationship.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteRelationshipById(relationshipid string, resp ...*http.Response) error {
	pp := struct {
		Relationshipid string
	}{
		Relationshipid: relationshipid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/relationships/{{.Relationshipid}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	return err
}

/*
	DeleteRule - catalog service endpoint
	Delete the rule with the specified resource name and its dependencies.
	Parameters:
		ruleresourcename: The resource name of a rule. For the default module, the resource name format is ruleName. Otherwise, the resource name format is module.ruleName.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteRule(ruleresourcename string, resp ...*http.Response) error {
	pp := struct {
		Ruleresourcename string
	}{
		Ruleresourcename: ruleresourcename,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/rules/{{.Ruleresourcename}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	return err
}

/*
	DeleteRuleById - catalog service endpoint
	Delete a specific rule. Deleting a rule also deleletes any objects that are dependents of that rule, such as rule actions.
	Parameters:
		ruleid: ID of a Field.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteRuleById(ruleid string, resp ...*http.Response) error {
	pp := struct {
		Ruleid string
	}{
		Ruleid: ruleid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/rules/{{.Ruleid}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	return err
}

/*
	DeleteWorkflowBuildById - catalog service endpoint
	Delete the workflow build with the specified workflow build ID.
	Parameters:
		workflowid: ID of a workflow.
		workflowbuildid: ID of a workflow build.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteWorkflowBuildById(workflowid string, workflowbuildid string, resp ...*http.Response) error {
	pp := struct {
		Workflowid      string
		Workflowbuildid string
	}{
		Workflowid:      workflowid,
		Workflowbuildid: workflowbuildid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/workflows/{{.Workflowid}}/builds/{{.Workflowbuildid}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	return err
}

/*
	DeleteWorkflowById - catalog service endpoint
	Delete the workflow with the specified workflow ID.
	Parameters:
		workflowid: ID of a workflow.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteWorkflowById(workflowid string, resp ...*http.Response) error {
	pp := struct {
		Workflowid string
	}{
		Workflowid: workflowid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/workflows/{{.Workflowid}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	return err
}

/*
	DeleteWorkflowRunById - catalog service endpoint
	Delete the workflow run with the specified workflow run ID.
	Parameters:
		workflowid: ID of a workflow.
		workflowbuildid: ID of a workflow build.
		workflowrunid: ID of a workflow run.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteWorkflowRunById(workflowid string, workflowbuildid string, workflowrunid string, resp ...*http.Response) error {
	pp := struct {
		Workflowid      string
		Workflowbuildid string
		Workflowrunid   string
	}{
		Workflowid:      workflowid,
		Workflowbuildid: workflowbuildid,
		Workflowrunid:   workflowrunid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/workflows/{{.Workflowid}}/builds/{{.Workflowbuildid}}/runs/{{.Workflowrunid}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	return err
}

/*
	GetActionByIdForRule - catalog service endpoint
	Return an action that is part of a specified rule.
	Parameters:
		ruleresourcename: The resource name of a rule. For the default module, the resource name format is ruleName. Otherwise, the resource name format is module.ruleName.
		actionid: ID of an Action.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetActionByIdForRule(ruleresourcename string, actionid string, resp ...*http.Response) (*Action, error) {
	pp := struct {
		Ruleresourcename string
		Actionid         string
	}{
		Ruleresourcename: ruleresourcename,
		Actionid:         actionid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/rules/{{.Ruleresourcename}}/actions/{{.Actionid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb Action
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetActionByIdForRuleById - catalog service endpoint
	Return information about an action that is part of a specific rule.
	Parameters:
		ruleid: ID of a Field.
		actionid: ID of an Action.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetActionByIdForRuleById(ruleid string, actionid string, resp ...*http.Response) (*Action, error) {
	pp := struct {
		Ruleid   string
		Actionid string
	}{
		Ruleid:   ruleid,
		Actionid: actionid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/rules/{{.Ruleid}}/actions/{{.Actionid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb Action
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetDashboardByID - catalog service endpoint
	Return information about a dashboard with the specified ID.
	Parameters:
		dashboardid: ID of a dashboard.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetDashboardByID(dashboardid string, resp ...*http.Response) (*Dashboard, error) {
	pp := struct {
		Dashboardid string
	}{
		Dashboardid: dashboardid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/dashboards/{{.Dashboardid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb Dashboard
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetDashboardByResourceName - catalog service endpoint
	Return information about a dashboard with the specified resource name.
	Parameters:
		dashboardresourcename: The resource name of a dashvboard. The resource name format is module.dashboardname.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetDashboardByResourceName(dashboardresourcename string, resp ...*http.Response) (*Dashboard, error) {
	pp := struct {
		Dashboardresourcename string
	}{
		Dashboardresourcename: dashboardresourcename,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/dashboards/{{.Dashboardresourcename}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb Dashboard
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetDataset - catalog service endpoint
	Return the dataset with the specified resource name. For the default module, the resource name format is datasetName. Otherwise, the resource name format is module.datasetName.
	Parameters:
		datasetresourcename: The resource name of a dataset. For the default module, the resource name format is datasetName. Otherwise, the resource name format is module.datasetName.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetDataset(datasetresourcename string, resp ...*http.Response) (*Dataset, error) {
	pp := struct {
		Datasetresourcename string
	}{
		Datasetresourcename: datasetresourcename,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetresourcename}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb Dataset
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetDatasetById - catalog service endpoint
	Return information about the dataset with the specified ID.
	Parameters:
		datasetid: ID of a Dataset.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetDatasetById(datasetid string, resp ...*http.Response) (*Dataset, error) {
	pp := struct {
		Datasetid string
	}{
		Datasetid: datasetid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb Dataset
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetFieldByID - catalog service endpoint
	Get a field that corresponds to a specific field ID.
	Parameters:
		fieldid: ID of a Field.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetFieldByID(fieldid string, resp ...*http.Response) (*Field, error) {
	pp := struct {
		Fieldid string
	}{
		Fieldid: fieldid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/fields/{{.Fieldid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb Field
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetFieldByIdForDataset - catalog service endpoint
	Return a field that is part of a specific dataset.
	Parameters:
		datasetresourcename: The resource name of a dataset. For the default module, the resource name format is datasetName. Otherwise, the resource name format is module.datasetName.
		fieldid: ID of a Field.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetFieldByIdForDataset(datasetresourcename string, fieldid string, resp ...*http.Response) (*Field, error) {
	pp := struct {
		Datasetresourcename string
		Fieldid             string
	}{
		Datasetresourcename: datasetresourcename,
		Fieldid:             fieldid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetresourcename}}/fields/{{.Fieldid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb Field
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetFieldByIdForDatasetById - catalog service endpoint
	Return a field that is part of a specific dataset.
	Parameters:
		datasetid: ID of a Dataset.
		fieldid: ID of a Field.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetFieldByIdForDatasetById(datasetid string, fieldid string, resp ...*http.Response) (*Field, error) {
	pp := struct {
		Datasetid string
		Fieldid   string
	}{
		Datasetid: datasetid,
		Fieldid:   fieldid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetid}}/fields/{{.Fieldid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb Field
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetRelationshipById - catalog service endpoint
	Get a specific relationship.
	Parameters:
		relationshipid: ID of a relationship.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetRelationshipById(relationshipid string, resp ...*http.Response) (*Relationship, error) {
	pp := struct {
		Relationshipid string
	}{
		Relationshipid: relationshipid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/relationships/{{.Relationshipid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb Relationship
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetRule - catalog service endpoint
	Get a rule with a specified resource name.
	Parameters:
		ruleresourcename: The resource name of a rule. For the default module, the resource name format is ruleName. Otherwise, the resource name format is module.ruleName.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetRule(ruleresourcename string, resp ...*http.Response) (*Rule, error) {
	pp := struct {
		Ruleresourcename string
	}{
		Ruleresourcename: ruleresourcename,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/rules/{{.Ruleresourcename}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb Rule
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetRuleById - catalog service endpoint
	Get information about a specific rule.
	Parameters:
		ruleid: ID of a Field.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetRuleById(ruleid string, resp ...*http.Response) (*Rule, error) {
	pp := struct {
		Ruleid string
	}{
		Ruleid: ruleid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/rules/{{.Ruleid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb Rule
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetWorkflowBuildById - catalog service endpoint
	Return information about the workflow build with the specified workflow build ID.
	Parameters:
		workflowid: ID of a workflow.
		workflowbuildid: ID of a workflow build.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetWorkflowBuildById(workflowid string, workflowbuildid string, resp ...*http.Response) (*WorkflowBuild, error) {
	pp := struct {
		Workflowid      string
		Workflowbuildid string
	}{
		Workflowid:      workflowid,
		Workflowbuildid: workflowbuildid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/workflows/{{.Workflowid}}/builds/{{.Workflowbuildid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb WorkflowBuild
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetWorkflowById - catalog service endpoint
	Return information about a workflow with the specified workflow ID.
	Parameters:
		workflowid: ID of a workflow.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetWorkflowById(workflowid string, resp ...*http.Response) (*Workflow, error) {
	pp := struct {
		Workflowid string
	}{
		Workflowid: workflowid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/workflows/{{.Workflowid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb Workflow
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetWorkflowRunById - catalog service endpoint
	Return information about the workflow run with the specified workflow build ID.
	Parameters:
		workflowid: ID of a workflow.
		workflowbuildid: ID of a workflow build.
		workflowrunid: ID of a workflow run.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetWorkflowRunById(workflowid string, workflowbuildid string, workflowrunid string, resp ...*http.Response) (*WorkflowRun, error) {
	pp := struct {
		Workflowid      string
		Workflowbuildid string
		Workflowrunid   string
	}{
		Workflowid:      workflowid,
		Workflowbuildid: workflowbuildid,
		Workflowrunid:   workflowrunid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/workflows/{{.Workflowid}}/builds/{{.Workflowbuildid}}/runs/{{.Workflowrunid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb WorkflowRun
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	ListActionsForRule - catalog service endpoint
	Return the list of actions that are part of a specified rule.
	Parameters:
		ruleresourcename: The resource name of a rule. For the default module, the resource name format is ruleName. Otherwise, the resource name format is module.ruleName.
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListActionsForRule(ruleresourcename string, query *ListActionsForRuleQueryParams, resp ...*http.Response) ([]Action, error) {
	values := util.ParseURLParams(query)
	pp := struct {
		Ruleresourcename string
	}{
		Ruleresourcename: ruleresourcename,
	}
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/catalog/v2beta1/rules/{{.Ruleresourcename}}/actions`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb []Action
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	ListActionsForRuleById - catalog service endpoint
	Return the set of actions that are part of a rule.
	Parameters:
		ruleid: ID of a Field.
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListActionsForRuleById(ruleid string, query *ListActionsForRuleByIdQueryParams, resp ...*http.Response) ([]Action, error) {
	values := util.ParseURLParams(query)
	pp := struct {
		Ruleid string
	}{
		Ruleid: ruleid,
	}
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/catalog/v2beta1/rules/{{.Ruleid}}/actions`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb []Action
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	ListAnnotationsForDatasetById - catalog service endpoint
	Return the set of annotations that are part of a dataset.
	Parameters:
		datasetid: ID of a Dataset.
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListAnnotationsForDatasetById(datasetid string, query *ListAnnotationsForDatasetByIdQueryParams, resp ...*http.Response) ([]Annotation, error) {
	values := util.ParseURLParams(query)
	pp := struct {
		Datasetid string
	}{
		Datasetid: datasetid,
	}
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetid}}/annotations`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb []Annotation
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	ListAnnotationsForDatasetByResourceName - catalog service endpoint
	Return the set of annotations that are part of a dataset.
	Parameters:
		datasetresourcename: The resource name of a dataset. For the default module, the resource name format is datasetName. Otherwise, the resource name format is module.datasetName.
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListAnnotationsForDatasetByResourceName(datasetresourcename string, query *ListAnnotationsForDatasetByResourceNameQueryParams, resp ...*http.Response) ([]Annotation, error) {
	values := util.ParseURLParams(query)
	pp := struct {
		Datasetresourcename string
	}{
		Datasetresourcename: datasetresourcename,
	}
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetresourcename}}/annotations`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb []Annotation
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	ListDashboards - catalog service endpoint
	Return a list of Dashboards.
	Parameters:
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListDashboards(resp ...*http.Response) ([]Dashboard, error) {
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/dashboards`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb []Dashboard
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	ListDatasets - catalog service endpoint
	Returns a list of all datasets, unless you specify a filter. Use a filter to return a specific list of datasets.
	Parameters:
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListDatasets(query *ListDatasetsQueryParams, resp ...*http.Response) ([]Dataset, error) {
	values := util.ParseURLParams(query)
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/catalog/v2beta1/datasets`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb []Dataset
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	ListFields - catalog service endpoint
	Get a list of all fields in the Catalog.
	Parameters:
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListFields(query *ListFieldsQueryParams, resp ...*http.Response) ([]Field, error) {
	values := util.ParseURLParams(query)
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/catalog/v2beta1/fields`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb []Field
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	ListFieldsForDataset - catalog service endpoint
	Return the list of fields that are part of a specified dataset.
	Parameters:
		datasetresourcename: The resource name of a dataset. For the default module, the resource name format is datasetName. Otherwise, the resource name format is module.datasetName.
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListFieldsForDataset(datasetresourcename string, query *ListFieldsForDatasetQueryParams, resp ...*http.Response) ([]Field, error) {
	values := util.ParseURLParams(query)
	pp := struct {
		Datasetresourcename string
	}{
		Datasetresourcename: datasetresourcename,
	}
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetresourcename}}/fields`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb []Field
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	ListFieldsForDatasetById - catalog service endpoint
	Return the set of fields for the specified dataset.
	Parameters:
		datasetid: ID of a Dataset.
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListFieldsForDatasetById(datasetid string, query *ListFieldsForDatasetByIdQueryParams, resp ...*http.Response) ([]Field, error) {
	values := util.ParseURLParams(query)
	pp := struct {
		Datasetid string
	}{
		Datasetid: datasetid,
	}
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetid}}/fields`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb []Field
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	ListModules - catalog service endpoint
	Return a list of all modules, unless you specify a filter. Use a filter to return a specific list of modules.
	Parameters:
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListModules(query *ListModulesQueryParams, resp ...*http.Response) ([]Module, error) {
	values := util.ParseURLParams(query)
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/catalog/v2beta1/modules`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb []Module
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	ListRelationships - catalog service endpoint
	Returns a list of all relationships, unless you specify a filter. Use a filter to return a specific list of relationships.
	Parameters:
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListRelationships(query *ListRelationshipsQueryParams, resp ...*http.Response) ([]Relationship, error) {
	values := util.ParseURLParams(query)
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/catalog/v2beta1/relationships`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb []Relationship
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	ListRules - catalog service endpoint
	Return a list of rules that match a filter query if it is given, otherwise return all rules.
	Parameters:
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListRules(query *ListRulesQueryParams, resp ...*http.Response) ([]Rule, error) {
	values := util.ParseURLParams(query)
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/catalog/v2beta1/rules`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb []Rule
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	ListWorkflowBuilds - catalog service endpoint
	Return a list of Machine Learning workflow builds.
	Parameters:
		workflowid: ID of a workflow.
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListWorkflowBuilds(workflowid string, query *ListWorkflowBuildsQueryParams, resp ...*http.Response) ([]WorkflowBuild, error) {
	values := util.ParseURLParams(query)
	pp := struct {
		Workflowid string
	}{
		Workflowid: workflowid,
	}
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/catalog/v2beta1/workflows/{{.Workflowid}}/builds`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb []WorkflowBuild
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	ListWorkflowRuns - catalog service endpoint
	Return a list of Machine Learning workflow runs for specified workflow build ID.
	Parameters:
		workflowid: ID of a workflow.
		workflowbuildid: ID of a workflow build.
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListWorkflowRuns(workflowid string, workflowbuildid string, query *ListWorkflowRunsQueryParams, resp ...*http.Response) ([]WorkflowRun, error) {
	values := util.ParseURLParams(query)
	pp := struct {
		Workflowid      string
		Workflowbuildid string
	}{
		Workflowid:      workflowid,
		Workflowbuildid: workflowbuildid,
	}
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/catalog/v2beta1/workflows/{{.Workflowid}}/builds/{{.Workflowbuildid}}/runs`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb []WorkflowRun
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	ListWorkflows - catalog service endpoint
	Return a list of Machine Learning workflow configurations.
	Parameters:
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListWorkflows(query *ListWorkflowsQueryParams, resp ...*http.Response) ([]Workflow, error) {
	values := util.ParseURLParams(query)
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/catalog/v2beta1/workflows`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb []Workflow
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	UpdateActionByIdForRule - catalog service endpoint
	Update the Action with the specified id for the specified Rule
	Parameters:
		ruleresourcename: The resource name of a rule. For the default module, the resource name format is ruleName. Otherwise, the resource name format is module.ruleName.
		actionid: ID of an Action.
		actionPatch: The fields to update in the specified action.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) UpdateActionByIdForRule(ruleresourcename string, actionid string, actionPatch ActionPatch, resp ...*http.Response) (*Action, error) {
	pp := struct {
		Ruleresourcename string
		Actionid         string
	}{
		Ruleresourcename: ruleresourcename,
		Actionid:         actionid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/rules/{{.Ruleresourcename}}/actions/{{.Actionid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Patch(services.RequestParams{URL: u, Body: actionPatch})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb Action
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	UpdateActionByIdForRuleById - catalog service endpoint
	Update an action for a specific rule.
	Parameters:
		ruleid: ID of a Field.
		actionid: ID of an Action.
		actionPatch: The properties to update in the specified action.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) UpdateActionByIdForRuleById(ruleid string, actionid string, actionPatch ActionPatch, resp ...*http.Response) (*Action, error) {
	pp := struct {
		Ruleid   string
		Actionid string
	}{
		Ruleid:   ruleid,
		Actionid: actionid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/rules/{{.Ruleid}}/actions/{{.Actionid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Patch(services.RequestParams{URL: u, Body: actionPatch})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb Action
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	UpdateDashboardById - catalog service endpoint
	Update the dashboard with the specified ID.
	Parameters:
		dashboardid: ID of a dashboard.
		dashboardPatch: An updated representation of the dashboard to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) UpdateDashboardById(dashboardid string, dashboardPatch DashboardPatch, resp ...*http.Response) error {
	pp := struct {
		Dashboardid string
	}{
		Dashboardid: dashboardid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/dashboards/{{.Dashboardid}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Patch(services.RequestParams{URL: u, Body: dashboardPatch})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	return err
}

/*
	UpdateDashboardByResourceName - catalog service endpoint
	Update the dashboard with the specified resource name.
	Parameters:
		dashboardresourcename: The resource name of a dashvboard. The resource name format is module.dashboardname.
		dashboardPatch: An updated representation of the dashboard to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) UpdateDashboardByResourceName(dashboardresourcename string, dashboardPatch DashboardPatch, resp ...*http.Response) error {
	pp := struct {
		Dashboardresourcename string
	}{
		Dashboardresourcename: dashboardresourcename,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/dashboards/{{.Dashboardresourcename}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Patch(services.RequestParams{URL: u, Body: dashboardPatch})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	return err
}

/*
	UpdateDataset - catalog service endpoint
	Update the dataset with the specified resource name. For the default module, the resource name format is datasetName. Otherwise, the resource name format is module.datasetName.
	Parameters:
		datasetresourcename: The resource name of a dataset. For the default module, the resource name format is datasetName. Otherwise, the resource name format is module.datasetName.
		datasetPatch: An updated representation of the dataset to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) UpdateDataset(datasetresourcename string, datasetPatch DatasetPatch, resp ...*http.Response) (*Dataset, error) {
	pp := struct {
		Datasetresourcename string
	}{
		Datasetresourcename: datasetresourcename,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetresourcename}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Patch(services.RequestParams{URL: u, Body: datasetPatch})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb Dataset
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	UpdateDatasetById - catalog service endpoint
	Update a specific dataset.
	Parameters:
		datasetid: ID of a Dataset.
		datasetPatch: An updated representation of the dataset to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) UpdateDatasetById(datasetid string, datasetPatch DatasetPatch, resp ...*http.Response) (*Dataset, error) {
	pp := struct {
		Datasetid string
	}{
		Datasetid: datasetid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Patch(services.RequestParams{URL: u, Body: datasetPatch})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb Dataset
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	UpdateFieldByIdForDataset - catalog service endpoint
	Update a field with a specified ID for a specified dataset.
	Parameters:
		datasetresourcename: The resource name of a dataset. For the default module, the resource name format is datasetName. Otherwise, the resource name format is module.datasetName.
		fieldid: ID of a Field.
		fieldPatch: The properties to update in the specified field.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) UpdateFieldByIdForDataset(datasetresourcename string, fieldid string, fieldPatch FieldPatch, resp ...*http.Response) (*Field, error) {
	pp := struct {
		Datasetresourcename string
		Fieldid             string
	}{
		Datasetresourcename: datasetresourcename,
		Fieldid:             fieldid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetresourcename}}/fields/{{.Fieldid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Patch(services.RequestParams{URL: u, Body: fieldPatch})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb Field
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	UpdateFieldByIdForDatasetById - catalog service endpoint
	Update a field for a specific dataset.
	Parameters:
		datasetid: ID of a Dataset.
		fieldid: ID of a Field.
		fieldPatch: The properties to update in the specified field.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) UpdateFieldByIdForDatasetById(datasetid string, fieldid string, fieldPatch FieldPatch, resp ...*http.Response) (*Field, error) {
	pp := struct {
		Datasetid string
		Fieldid   string
	}{
		Datasetid: datasetid,
		Fieldid:   fieldid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetid}}/fields/{{.Fieldid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Patch(services.RequestParams{URL: u, Body: fieldPatch})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb Field
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	UpdateRelationshipById - catalog service endpoint
	Update a specific relationship.
	Parameters:
		relationshipid: ID of a relationship.
		relationshipPatch: The properties to update in the specified relationship.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) UpdateRelationshipById(relationshipid string, relationshipPatch RelationshipPatch, resp ...*http.Response) (*Relationship, error) {
	pp := struct {
		Relationshipid string
	}{
		Relationshipid: relationshipid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/relationships/{{.Relationshipid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Patch(services.RequestParams{URL: u, Body: relationshipPatch})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb Relationship
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	UpdateRule - catalog service endpoint
	Update the Rule with the specified resourcename
	Parameters:
		ruleresourcename: The resource name of a rule. For the default module, the resource name format is ruleName. Otherwise, the resource name format is module.ruleName.
		rulePatch: The properties to update in the specified rule.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) UpdateRule(ruleresourcename string, rulePatch RulePatch, resp ...*http.Response) (*Rule, error) {
	pp := struct {
		Ruleresourcename string
	}{
		Ruleresourcename: ruleresourcename,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/rules/{{.Ruleresourcename}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Patch(services.RequestParams{URL: u, Body: rulePatch})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb Rule
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	UpdateRuleById - catalog service endpoint
	Update a specific rule.
	Parameters:
		ruleid: ID of a Field.
		rulePatch: The properties to update in the specified rule.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) UpdateRuleById(ruleid string, rulePatch RulePatch, resp ...*http.Response) (*Rule, error) {
	pp := struct {
		Ruleid string
	}{
		Ruleid: ruleid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/rules/{{.Ruleid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Patch(services.RequestParams{URL: u, Body: rulePatch})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	if err != nil {
		return nil, err
	}
	var rb Rule
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	UpdateWorkflowBuildById - catalog service endpoint
	Update the workflow build with the specified workflow build ID.
	Parameters:
		workflowid: ID of a workflow.
		workflowbuildid: ID of a workflow build.
		workflowBuildPatch: An updated representation of the workflow build to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) UpdateWorkflowBuildById(workflowid string, workflowbuildid string, workflowBuildPatch WorkflowBuildPatch, resp ...*http.Response) error {
	pp := struct {
		Workflowid      string
		Workflowbuildid string
	}{
		Workflowid:      workflowid,
		Workflowbuildid: workflowbuildid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/workflows/{{.Workflowid}}/builds/{{.Workflowbuildid}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Patch(services.RequestParams{URL: u, Body: workflowBuildPatch})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	return err
}

/*
	UpdateWorkflowById - catalog service endpoint
	Update the workflow with the specified workflow ID.
	Parameters:
		workflowid: ID of a workflow.
		workflowPatch: An updated representation of the workflow to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) UpdateWorkflowById(workflowid string, workflowPatch WorkflowPatch, resp ...*http.Response) error {
	pp := struct {
		Workflowid string
	}{
		Workflowid: workflowid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/workflows/{{.Workflowid}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Patch(services.RequestParams{URL: u, Body: workflowPatch})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	return err
}

/*
	UpdateWorkflowRunById - catalog service endpoint
	Update the workflow run with the specified workflow run ID.
	Parameters:
		workflowid: ID of a workflow.
		workflowbuildid: ID of a workflow build.
		workflowrunid: ID of a workflow run.
		workflowRunPatch: An updated representation of the workflow run to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) UpdateWorkflowRunById(workflowid string, workflowbuildid string, workflowrunid string, workflowRunPatch WorkflowRunPatch, resp ...*http.Response) error {
	pp := struct {
		Workflowid      string
		Workflowbuildid string
		Workflowrunid   string
	}{
		Workflowid:      workflowid,
		Workflowbuildid: workflowbuildid,
		Workflowrunid:   workflowrunid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/workflows/{{.Workflowid}}/builds/{{.Workflowbuildid}}/runs/{{.Workflowrunid}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Patch(services.RequestParams{URL: u, Body: workflowRunPatch})
	// populate input *http.Response if provided
	if len(resp) > 0 && resp[0] != nil {
		*resp[0] = *response
	}
	return err
}
