/*
 * Copyright Â© 2020 Splunk, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"): you may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * Metadata Catalog service
 *
 * With the Metadata Catalog in Splunk Cloud Services you can create and manage knowledge objects such as datasets, fields, rules, actions, dashboards, and workflows.
 *
 * API version: v2beta1.4 (recommended default)
 * Generated by: OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.
 */

package catalog

import (
	"net/http"

	"github.com/splunk/go-dependencies/services"
	"github.com/splunk/go-dependencies/util"
)

const serviceCluster = "api"

type Service services.BaseService

// NewService creates a new catalog service client from the given Config
func NewService(iClient services.IClient) *Service {
	return &Service{Client: iClient}
}

/*
	CreateActionForRule - catalog service endpoint
	Creates a new action for a rule with the specified resource name.
	Parameters:
		ruleresourcename: The resource name of a rule. For the default module, the resource name format is ruleName. Otherwise, the resource name format is module.ruleName.
		actionPost: The JSON representation of the action to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateActionForRule(ruleresourcename string, actionPost ActionPost, resp ...*http.Response) (*Action, error) {
	pp := struct {
		Ruleresourcename string
	}{
		Ruleresourcename: ruleresourcename,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/rules/{{.Ruleresourcename}}/actions`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: actionPost})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Action
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CreateActionForRuleById - catalog service endpoint
	Creates a new action for the specified rule.
	Parameters:
		ruleid: ID of a Field.
		actionPost: The JSON representation of the action to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateActionForRuleById(ruleid string, actionPost ActionPost, resp ...*http.Response) (*Action, error) {
	pp := struct {
		Ruleid string
	}{
		Ruleid: ruleid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/rules/{{.Ruleid}}/actions`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: actionPost})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Action
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CreateAnnotationForDashboardbyId - catalog service endpoint
	Creates a new annotation for the specified dashboard.
	Parameters:
		dashboardid: ID of a dashboard.
		requestBody: The JSON representation of the annotation to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateAnnotationForDashboardbyId(dashboardid string, requestBody map[string]string, resp ...*http.Response) (*Annotation, error) {
	pp := struct {
		Dashboardid string
	}{
		Dashboardid: dashboardid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/dashboards/{{.Dashboardid}}/annotations`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: requestBody})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Annotation
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CreateAnnotationForDashboardsByResourceName - catalog service endpoint
	Creates a new annotation for the specified dataset resource name.
	Parameters:
		dashboardresourcename: The resource name of a dashvboard. The resource name format is module.dashboardname.
		requestBody: The JSON representation of the annotation to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateAnnotationForDashboardsByResourceName(dashboardresourcename string, requestBody map[string]string, resp ...*http.Response) (*Annotation, error) {
	pp := struct {
		Dashboardresourcename string
	}{
		Dashboardresourcename: dashboardresourcename,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/dashboards/{{.Dashboardresourcename}}/annotations`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: requestBody})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Annotation
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CreateAnnotationForDatasetById - catalog service endpoint
	Creates a new annotation for the specified dataset.
	Parameters:
		datasetid: ID of a Dataset.
		requestBody: The JSON representation of the annotation to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateAnnotationForDatasetById(datasetid string, requestBody map[string]string, resp ...*http.Response) (*Annotation, error) {
	pp := struct {
		Datasetid string
	}{
		Datasetid: datasetid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetid}}/annotations`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: requestBody})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Annotation
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CreateAnnotationForDatasetByResourceName - catalog service endpoint
	Creates a new annotation for the specified dataset.
	Parameters:
		datasetresourcename: The resource name of a dataset. For the default module, the resource name format is datasetName. Otherwise, the resource name format is module.datasetName.
		requestBody: The JSON representation of the annotation to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateAnnotationForDatasetByResourceName(datasetresourcename string, requestBody map[string]string, resp ...*http.Response) (*Annotation, error) {
	pp := struct {
		Datasetresourcename string
	}{
		Datasetresourcename: datasetresourcename,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetresourcename}}/annotations`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: requestBody})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Annotation
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CreateDashboard - catalog service endpoint
	Creates a new dashboard.
	Parameters:
		dashboardPost: The JSON representation of the Dashboard to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateDashboard(dashboardPost DashboardPost, resp ...*http.Response) (*Dashboard, error) {
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/dashboards`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: dashboardPost})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Dashboard
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CreateDataset - catalog service endpoint
	Creates a new dataset.
	Parameters:
		datasetPost: JSON representation of the DatasetInfo to be persisted
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateDataset(datasetPost DatasetPost, resp ...*http.Response) (*Dataset, error) {
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: datasetPost})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Dataset
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CreateDatasetImport - catalog service endpoint
	Creates a new dataset import using the resource name of the imported dataset.
	Parameters:
		datasetresourcename: The resource name of a dataset. For the default module, the resource name format is datasetName. Otherwise, the resource name format is module.datasetName.
		datasetImportedBy
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateDatasetImport(datasetresourcename string, datasetImportedBy DatasetImportedBy, resp ...*http.Response) (*Dataset, error) {
	pp := struct {
		Datasetresourcename string
	}{
		Datasetresourcename: datasetresourcename,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetresourcename}}/imported-by`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: datasetImportedBy})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Dataset
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CreateDatasetImportById - catalog service endpoint
	Creates a new dataset import using the ID of the imported dataset.
	Parameters:
		datasetid: ID of a Dataset.
		datasetImportedBy
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateDatasetImportById(datasetid string, datasetImportedBy DatasetImportedBy, resp ...*http.Response) (*DatasetImportedBy, error) {
	pp := struct {
		Datasetid string
	}{
		Datasetid: datasetid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetid}}/imported-by`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: datasetImportedBy})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb DatasetImportedBy
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CreateDatasetImportByIdv1 - catalog service endpoint
	Creates a new dataset import using the ID of the imported dataset.
	Parameters:
		datasetid: ID of a Dataset.
		datasetImportedBy
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateDatasetImportByIdv1(datasetid string, datasetImportedBy DatasetImportedBy, resp ...*http.Response) (*DatasetImportedBy, error) {
	pp := struct {
		Datasetid string
	}{
		Datasetid: datasetid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetid}}/importedby`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: datasetImportedBy})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb DatasetImportedBy
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CreateDatasetImportv1 - catalog service endpoint
	Creates a new dataset import using the resource name of the imported dataset.
	Parameters:
		datasetresourcename: The resource name of a dataset. For the default module, the resource name format is datasetName. Otherwise, the resource name format is module.datasetName.
		datasetImportedBy
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateDatasetImportv1(datasetresourcename string, datasetImportedBy DatasetImportedBy, resp ...*http.Response) (*Dataset, error) {
	pp := struct {
		Datasetresourcename string
	}{
		Datasetresourcename: datasetresourcename,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetresourcename}}/importedby`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: datasetImportedBy})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Dataset
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CreateFieldForDataset - catalog service endpoint
	Creates a new field in the dataset with the specified resource name.
	Parameters:
		datasetresourcename: The resource name of a dataset. For the default module, the resource name format is datasetName. Otherwise, the resource name format is module.datasetName.
		fieldPost: The JSON representation of the field to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateFieldForDataset(datasetresourcename string, fieldPost FieldPost, resp ...*http.Response) (*Field, error) {
	pp := struct {
		Datasetresourcename string
	}{
		Datasetresourcename: datasetresourcename,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetresourcename}}/fields`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: fieldPost})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Field
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CreateFieldForDatasetById - catalog service endpoint
	Adds a new field to the dataset with the specified ID.
	Parameters:
		datasetid: ID of a Dataset.
		fieldPost: The JSON representation of the field to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateFieldForDatasetById(datasetid string, fieldPost FieldPost, resp ...*http.Response) (*Field, error) {
	pp := struct {
		Datasetid string
	}{
		Datasetid: datasetid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetid}}/fields`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: fieldPost})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Field
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CreateRelationship - catalog service endpoint
	Creates a new relationship.
	Parameters:
		relationshipPost: The JSON representation of the relationship to persist.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateRelationship(relationshipPost RelationshipPost, resp ...*http.Response) (*Relationship, error) {
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/relationships`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: relationshipPost})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Relationship
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CreateRule - catalog service endpoint
	Creates a new rule.
	Parameters:
		rulePost: The JSON representation of the rule to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateRule(rulePost RulePost, resp ...*http.Response) (*Rule, error) {
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/rules`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: rulePost})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Rule
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CreateWorkflow - catalog service endpoint
	Creates a new workflow configuration.
	Parameters:
		workflowPost: The JSON representation of the workflow to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateWorkflow(workflowPost WorkflowPost, resp ...*http.Response) (*Workflow, error) {
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/workflows`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: workflowPost})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Workflow
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CreateWorkflowBuild - catalog service endpoint
	Creates a new workflow build.
	Parameters:
		workflowid: ID of a workflow.
		workflowBuildPost: The JSON representation of the workflow build to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateWorkflowBuild(workflowid string, workflowBuildPost WorkflowBuildPost, resp ...*http.Response) (*WorkflowBuild, error) {
	pp := struct {
		Workflowid string
	}{
		Workflowid: workflowid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/workflows/{{.Workflowid}}/builds`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: workflowBuildPost})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb WorkflowBuild
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CreateWorkflowRun - catalog service endpoint
	Creates a new workflow run for the specified workflow build ID.
	Parameters:
		workflowid: ID of a workflow.
		workflowbuildid: ID of a workflow build.
		workflowRunPost: The JSON representation of the workflow run to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateWorkflowRun(workflowid string, workflowbuildid string, workflowRunPost WorkflowRunPost, resp ...*http.Response) (*WorkflowRun, error) {
	pp := struct {
		Workflowid      string
		Workflowbuildid string
	}{
		Workflowid:      workflowid,
		Workflowbuildid: workflowbuildid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/workflows/{{.Workflowid}}/builds/{{.Workflowbuildid}}/runs`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: workflowRunPost})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb WorkflowRun
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	DeleteActionByIdForRule - catalog service endpoint
	Deletes the action with the specified ID that is associated with the specified rule resource name.
	Parameters:
		ruleresourcename: The resource name of a rule. For the default module, the resource name format is ruleName. Otherwise, the resource name format is module.ruleName.
		actionid: ID of an Action.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteActionByIdForRule(ruleresourcename string, actionid string, resp ...*http.Response) error {
	pp := struct {
		Ruleresourcename string
		Actionid         string
	}{
		Ruleresourcename: ruleresourcename,
		Actionid:         actionid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/rules/{{.Ruleresourcename}}/actions/{{.Actionid}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	return err
}

/*
	DeleteActionByIdForRuleById - catalog service endpoint
	Deletes the action with the specified ID that is associated with the specified rule.
	Parameters:
		ruleid: ID of a Field.
		actionid: ID of an Action.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteActionByIdForRuleById(ruleid string, actionid string, resp ...*http.Response) error {
	pp := struct {
		Ruleid   string
		Actionid string
	}{
		Ruleid:   ruleid,
		Actionid: actionid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/rules/{{.Ruleid}}/actions/{{.Actionid}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	return err
}

/*
	DeleteAnnotationOfDashboardById - catalog service endpoint
	Deletes the annotation with the speciifed ID that is associted with the specified dashboard.
	Parameters:
		dashboardid: ID of a dashboard.
		annotationid: ID of a annotation.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteAnnotationOfDashboardById(dashboardid string, annotationid string, resp ...*http.Response) error {
	pp := struct {
		Dashboardid  string
		Annotationid string
	}{
		Dashboardid:  dashboardid,
		Annotationid: annotationid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/dashboards/{{.Dashboardid}}/annotations/{{.Annotationid}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	return err
}

/*
	DeleteAnnotationOfDashboardByResourceName - catalog service endpoint
	Deletes the annotation with the specified ID that is associated with the specified dashboard resource name.
	Parameters:
		dashboardresourcename: The resource name of a dashvboard. The resource name format is module.dashboardname.
		annotationid: ID of a annotation.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteAnnotationOfDashboardByResourceName(dashboardresourcename string, annotationid string, resp ...*http.Response) error {
	pp := struct {
		Dashboardresourcename string
		Annotationid          string
	}{
		Dashboardresourcename: dashboardresourcename,
		Annotationid:          annotationid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/dashboards/{{.Dashboardresourcename}}/annotations/{{.Annotationid}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	return err
}

/*
	DeleteAnnotationOfDatasetById - catalog service endpoint
	Deletes the annotation with the specified ID that is associated with the specified dataset.
	Parameters:
		datasetid: ID of a Dataset.
		annotationid: ID of a annotation.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteAnnotationOfDatasetById(datasetid string, annotationid string, resp ...*http.Response) error {
	pp := struct {
		Datasetid    string
		Annotationid string
	}{
		Datasetid:    datasetid,
		Annotationid: annotationid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetid}}/annotations/{{.Annotationid}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	return err
}

/*
	DeleteAnnotationOfDatasetByResourceName - catalog service endpoint
	Deletes the annotation with the specified iD that is associated with the specified dataset resource name.
	Parameters:
		datasetresourcename: The resource name of a dataset. For the default module, the resource name format is datasetName. Otherwise, the resource name format is module.datasetName.
		annotationid: ID of a annotation.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteAnnotationOfDatasetByResourceName(datasetresourcename string, annotationid string, resp ...*http.Response) error {
	pp := struct {
		Datasetresourcename string
		Annotationid        string
	}{
		Datasetresourcename: datasetresourcename,
		Annotationid:        annotationid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetresourcename}}/annotations/{{.Annotationid}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	return err
}

/*
	DeleteDashboardById - catalog service endpoint
	Deletes the dashboard with the specified ID.
	Parameters:
		dashboardid: ID of a dashboard.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteDashboardById(dashboardid string, resp ...*http.Response) error {
	pp := struct {
		Dashboardid string
	}{
		Dashboardid: dashboardid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/dashboards/{{.Dashboardid}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	return err
}

/*
	DeleteDashboardByResourceName - catalog service endpoint
	Deletes the dashboard with the specified resource name.
	Parameters:
		dashboardresourcename: The resource name of a dashvboard. The resource name format is module.dashboardname.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteDashboardByResourceName(dashboardresourcename string, resp ...*http.Response) error {
	pp := struct {
		Dashboardresourcename string
	}{
		Dashboardresourcename: dashboardresourcename,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/dashboards/{{.Dashboardresourcename}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	return err
}

/*
	DeleteDataset - catalog service endpoint
	Deletes the dataset with the specified resource name, along with its dependencies. For the default module, the resource name format is datasetName. Otherwise, the resource name format is module.datasetName.
	Parameters:
		datasetresourcename: The resource name of a dataset. For the default module, the resource name format is datasetName. Otherwise, the resource name format is module.datasetName.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteDataset(datasetresourcename string, resp ...*http.Response) error {
	pp := struct {
		Datasetresourcename string
	}{
		Datasetresourcename: datasetresourcename,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetresourcename}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	return err
}

/*
	DeleteDatasetById - catalog service endpoint
	Deletes the dataset with the specified ID. Deleting a dataset also deletes its dependent objects, such as fields.
	Parameters:
		datasetid: ID of a Dataset.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteDatasetById(datasetid string, resp ...*http.Response) error {
	pp := struct {
		Datasetid string
	}{
		Datasetid: datasetid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetid}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	return err
}

/*
	DeleteFieldByIdForDataset - catalog service endpoint
	Deletes the field with the specified ID that is part of the specified dataset.
	Parameters:
		datasetresourcename: The resource name of a dataset. For the default module, the resource name format is datasetName. Otherwise, the resource name format is module.datasetName.
		fieldid: ID of a Field.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteFieldByIdForDataset(datasetresourcename string, fieldid string, resp ...*http.Response) error {
	pp := struct {
		Datasetresourcename string
		Fieldid             string
	}{
		Datasetresourcename: datasetresourcename,
		Fieldid:             fieldid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetresourcename}}/fields/{{.Fieldid}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	return err
}

/*
	DeleteFieldByIdForDatasetById - catalog service endpoint
	Deletes the field with the specified ID that is part of the specified dataset.
	Parameters:
		datasetid: ID of a Dataset.
		fieldid: ID of a Field.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteFieldByIdForDatasetById(datasetid string, fieldid string, resp ...*http.Response) error {
	pp := struct {
		Datasetid string
		Fieldid   string
	}{
		Datasetid: datasetid,
		Fieldid:   fieldid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetid}}/fields/{{.Fieldid}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	return err
}

/*
	DeleteRelationshipById - catalog service endpoint
	Deletes the relationship with the specified relationship ID. Deleting a relationship also deletes any objects that are dependents of that relationship, such as relationship fields.
	Parameters:
		relationshipid: ID of a relationship.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteRelationshipById(relationshipid string, resp ...*http.Response) error {
	pp := struct {
		Relationshipid string
	}{
		Relationshipid: relationshipid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/relationships/{{.Relationshipid}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	return err
}

/*
	DeleteRule - catalog service endpoint
	Deletes the rule with the specified resource name and its dependencies.
	Parameters:
		ruleresourcename: The resource name of a rule. For the default module, the resource name format is ruleName. Otherwise, the resource name format is module.ruleName.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteRule(ruleresourcename string, resp ...*http.Response) error {
	pp := struct {
		Ruleresourcename string
	}{
		Ruleresourcename: ruleresourcename,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/rules/{{.Ruleresourcename}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	return err
}

/*
	DeleteRuleById - catalog service endpoint
	Deletes the rule with the specfied ID. Deleting a rule also deleletes any objects that are dependents of that rule, such as rule actions.
	Parameters:
		ruleid: ID of a Field.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteRuleById(ruleid string, resp ...*http.Response) error {
	pp := struct {
		Ruleid string
	}{
		Ruleid: ruleid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/rules/{{.Ruleid}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	return err
}

/*
	DeleteWorkflowBuildById - catalog service endpoint
	Deletes the workflow build with the specified workflow build ID.
	Parameters:
		workflowid: ID of a workflow.
		workflowbuildid: ID of a workflow build.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteWorkflowBuildById(workflowid string, workflowbuildid string, resp ...*http.Response) error {
	pp := struct {
		Workflowid      string
		Workflowbuildid string
	}{
		Workflowid:      workflowid,
		Workflowbuildid: workflowbuildid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/workflows/{{.Workflowid}}/builds/{{.Workflowbuildid}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	return err
}

/*
	DeleteWorkflowById - catalog service endpoint
	Deletes the workflow with the specified workflow ID.
	Parameters:
		workflowid: ID of a workflow.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteWorkflowById(workflowid string, resp ...*http.Response) error {
	pp := struct {
		Workflowid string
	}{
		Workflowid: workflowid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/workflows/{{.Workflowid}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	return err
}

/*
	DeleteWorkflowRunById - catalog service endpoint
	Deletes the workflow run with the specified workflow run ID.
	Parameters:
		workflowid: ID of a workflow.
		workflowbuildid: ID of a workflow build.
		workflowrunid: ID of a workflow run.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteWorkflowRunById(workflowid string, workflowbuildid string, workflowrunid string, resp ...*http.Response) error {
	pp := struct {
		Workflowid      string
		Workflowbuildid string
		Workflowrunid   string
	}{
		Workflowid:      workflowid,
		Workflowbuildid: workflowbuildid,
		Workflowrunid:   workflowrunid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/workflows/{{.Workflowid}}/builds/{{.Workflowbuildid}}/runs/{{.Workflowrunid}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	return err
}

/*
	GetActionByIdForRule - catalog service endpoint
	Returns the action with the specified ID that is associated with the specified rule resource name.
	Parameters:
		ruleresourcename: The resource name of a rule. For the default module, the resource name format is ruleName. Otherwise, the resource name format is module.ruleName.
		actionid: ID of an Action.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetActionByIdForRule(ruleresourcename string, actionid string, resp ...*http.Response) (*Action, error) {
	pp := struct {
		Ruleresourcename string
		Actionid         string
	}{
		Ruleresourcename: ruleresourcename,
		Actionid:         actionid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/rules/{{.Ruleresourcename}}/actions/{{.Actionid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Action
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetActionByIdForRuleById - catalog service endpoint
	Returns information about the action with the specified ID that is associated with the specified rule.
	Parameters:
		ruleid: ID of a Field.
		actionid: ID of an Action.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetActionByIdForRuleById(ruleid string, actionid string, resp ...*http.Response) (*Action, error) {
	pp := struct {
		Ruleid   string
		Actionid string
	}{
		Ruleid:   ruleid,
		Actionid: actionid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/rules/{{.Ruleid}}/actions/{{.Actionid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Action
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetDashboardById - catalog service endpoint
	Returns information about the dashboard with the specified ID.
	Parameters:
		dashboardid: ID of a dashboard.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetDashboardById(dashboardid string, resp ...*http.Response) (*Dashboard, error) {
	pp := struct {
		Dashboardid string
	}{
		Dashboardid: dashboardid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/dashboards/{{.Dashboardid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Dashboard
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetDashboardByResourceName - catalog service endpoint
	Returns information about the dashboard with the specified resource name.
	Parameters:
		dashboardresourcename: The resource name of a dashvboard. The resource name format is module.dashboardname.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetDashboardByResourceName(dashboardresourcename string, resp ...*http.Response) (*Dashboard, error) {
	pp := struct {
		Dashboardresourcename string
	}{
		Dashboardresourcename: dashboardresourcename,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/dashboards/{{.Dashboardresourcename}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Dashboard
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetDataset - catalog service endpoint
	Returns the dataset with the specified resource name. For the default module, the resource name format is datasetName. Otherwise, the resource name format is module.datasetName.
	Parameters:
		datasetresourcename: The resource name of a dataset. For the default module, the resource name format is datasetName. Otherwise, the resource name format is module.datasetName.
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetDataset(datasetresourcename string, query *GetDatasetQueryParams, resp ...*http.Response) (*DatasetGet, error) {
	values := util.ParseURLParams(query)
	pp := struct {
		Datasetresourcename string
	}{
		Datasetresourcename: datasetresourcename,
	}
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetresourcename}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb DatasetGet
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetDatasetById - catalog service endpoint
	Returns information about the dataset with the specified ID.
	Parameters:
		datasetid: ID of a Dataset.
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetDatasetById(datasetid string, query *GetDatasetByIdQueryParams, resp ...*http.Response) (*DatasetGet, error) {
	values := util.ParseURLParams(query)
	pp := struct {
		Datasetid string
	}{
		Datasetid: datasetid,
	}
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb DatasetGet
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetFieldById - catalog service endpoint
	Returns the field with the specified ID.
	Parameters:
		fieldid: ID of a Field.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetFieldById(fieldid string, resp ...*http.Response) (*Field, error) {
	pp := struct {
		Fieldid string
	}{
		Fieldid: fieldid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/fields/{{.Fieldid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Field
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetFieldByIdForDataset - catalog service endpoint
	Returns the field with the specified ID that is part of the specified dataset.
	Parameters:
		datasetresourcename: The resource name of a dataset. For the default module, the resource name format is datasetName. Otherwise, the resource name format is module.datasetName.
		fieldid: ID of a Field.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetFieldByIdForDataset(datasetresourcename string, fieldid string, resp ...*http.Response) (*Field, error) {
	pp := struct {
		Datasetresourcename string
		Fieldid             string
	}{
		Datasetresourcename: datasetresourcename,
		Fieldid:             fieldid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetresourcename}}/fields/{{.Fieldid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Field
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetFieldByIdForDatasetById - catalog service endpoint
	Returns the field with the specified ID that is part of the specified dataset.
	Parameters:
		datasetid: ID of a Dataset.
		fieldid: ID of a Field.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetFieldByIdForDatasetById(datasetid string, fieldid string, resp ...*http.Response) (*Field, error) {
	pp := struct {
		Datasetid string
		Fieldid   string
	}{
		Datasetid: datasetid,
		Fieldid:   fieldid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetid}}/fields/{{.Fieldid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Field
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetRelationshipById - catalog service endpoint
	Returns the relationship with the specified relationship ID.
	Parameters:
		relationshipid: ID of a relationship.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetRelationshipById(relationshipid string, resp ...*http.Response) (*Relationship, error) {
	pp := struct {
		Relationshipid string
	}{
		Relationshipid: relationshipid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/relationships/{{.Relationshipid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Relationship
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetRule - catalog service endpoint
	Returrns the rule with the specified resource name.
	Parameters:
		ruleresourcename: The resource name of a rule. For the default module, the resource name format is ruleName. Otherwise, the resource name format is module.ruleName.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetRule(ruleresourcename string, resp ...*http.Response) (*Rule, error) {
	pp := struct {
		Ruleresourcename string
	}{
		Ruleresourcename: ruleresourcename,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/rules/{{.Ruleresourcename}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Rule
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetRuleById - catalog service endpoint
	Returns information about rule with the specified rule ID.
	Parameters:
		ruleid: ID of a Field.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetRuleById(ruleid string, resp ...*http.Response) (*Rule, error) {
	pp := struct {
		Ruleid string
	}{
		Ruleid: ruleid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/rules/{{.Ruleid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Rule
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetWorkflowBuildById - catalog service endpoint
	Returns information about the workflow build with the specified workflow build ID.
	Parameters:
		workflowid: ID of a workflow.
		workflowbuildid: ID of a workflow build.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetWorkflowBuildById(workflowid string, workflowbuildid string, resp ...*http.Response) (*WorkflowBuild, error) {
	pp := struct {
		Workflowid      string
		Workflowbuildid string
	}{
		Workflowid:      workflowid,
		Workflowbuildid: workflowbuildid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/workflows/{{.Workflowid}}/builds/{{.Workflowbuildid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb WorkflowBuild
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetWorkflowById - catalog service endpoint
	Returns information about the workflow with the specified workflow ID.
	Parameters:
		workflowid: ID of a workflow.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetWorkflowById(workflowid string, resp ...*http.Response) (*Workflow, error) {
	pp := struct {
		Workflowid string
	}{
		Workflowid: workflowid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/workflows/{{.Workflowid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Workflow
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetWorkflowRunById - catalog service endpoint
	Returns information about the workflow run with the specified workflow build ID.
	Parameters:
		workflowid: ID of a workflow.
		workflowbuildid: ID of a workflow build.
		workflowrunid: ID of a workflow run.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetWorkflowRunById(workflowid string, workflowbuildid string, workflowrunid string, resp ...*http.Response) (*WorkflowRun, error) {
	pp := struct {
		Workflowid      string
		Workflowbuildid string
		Workflowrunid   string
	}{
		Workflowid:      workflowid,
		Workflowbuildid: workflowbuildid,
		Workflowrunid:   workflowrunid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/workflows/{{.Workflowid}}/builds/{{.Workflowbuildid}}/runs/{{.Workflowrunid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb WorkflowRun
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	ListActionsForRule - catalog service endpoint
	Returns the list of actions that are associated with the specified rule.
	Parameters:
		ruleresourcename: The resource name of a rule. For the default module, the resource name format is ruleName. Otherwise, the resource name format is module.ruleName.
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListActionsForRule(ruleresourcename string, query *ListActionsForRuleQueryParams, resp ...*http.Response) ([]Action, error) {
	values := util.ParseURLParams(query)
	pp := struct {
		Ruleresourcename string
	}{
		Ruleresourcename: ruleresourcename,
	}
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/catalog/v2beta1/rules/{{.Ruleresourcename}}/actions`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb []Action
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	ListActionsForRuleById - catalog service endpoint
	Returns the set of actions that are part of the specified rule.
	Parameters:
		ruleid: ID of a Field.
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListActionsForRuleById(ruleid string, query *ListActionsForRuleByIdQueryParams, resp ...*http.Response) ([]Action, error) {
	values := util.ParseURLParams(query)
	pp := struct {
		Ruleid string
	}{
		Ruleid: ruleid,
	}
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/catalog/v2beta1/rules/{{.Ruleid}}/actions`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb []Action
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	ListAnnotations - catalog service endpoint
	Returns the set of annotations across all objects.
	Parameters:
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListAnnotations(query *ListAnnotationsQueryParams, resp ...*http.Response) ([]Annotation, error) {
	values := util.ParseURLParams(query)
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/catalog/v2beta1/annotations`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb []Annotation
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	ListAnnotationsForDashboardById - catalog service endpoint
	Returns the set of annotations that are associated with the specified dashboard.
	Parameters:
		dashboardid: ID of a dashboard.
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListAnnotationsForDashboardById(dashboardid string, query *ListAnnotationsForDashboardByIdQueryParams, resp ...*http.Response) ([]Annotation, error) {
	values := util.ParseURLParams(query)
	pp := struct {
		Dashboardid string
	}{
		Dashboardid: dashboardid,
	}
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/catalog/v2beta1/dashboards/{{.Dashboardid}}/annotations`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb []Annotation
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	ListAnnotationsForDashboardByResourceName - catalog service endpoint
	Returns the set of annotations that are associated with the specified dashboard resource name.
	Parameters:
		dashboardresourcename: The resource name of a dashvboard. The resource name format is module.dashboardname.
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListAnnotationsForDashboardByResourceName(dashboardresourcename string, query *ListAnnotationsForDashboardByResourceNameQueryParams, resp ...*http.Response) ([]Annotation, error) {
	values := util.ParseURLParams(query)
	pp := struct {
		Dashboardresourcename string
	}{
		Dashboardresourcename: dashboardresourcename,
	}
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/catalog/v2beta1/dashboards/{{.Dashboardresourcename}}/annotations`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb []Annotation
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	ListAnnotationsForDatasetById - catalog service endpoint
	Returns the set of annotations that are associated with the specified dataset.
	Parameters:
		datasetid: ID of a Dataset.
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListAnnotationsForDatasetById(datasetid string, query *ListAnnotationsForDatasetByIdQueryParams, resp ...*http.Response) ([]Annotation, error) {
	values := util.ParseURLParams(query)
	pp := struct {
		Datasetid string
	}{
		Datasetid: datasetid,
	}
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetid}}/annotations`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb []Annotation
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	ListAnnotationsForDatasetByResourceName - catalog service endpoint
	Returns the set of annotations that are associated with the specified dataset resource name.
	Parameters:
		datasetresourcename: The resource name of a dataset. For the default module, the resource name format is datasetName. Otherwise, the resource name format is module.datasetName.
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListAnnotationsForDatasetByResourceName(datasetresourcename string, query *ListAnnotationsForDatasetByResourceNameQueryParams, resp ...*http.Response) ([]Annotation, error) {
	values := util.ParseURLParams(query)
	pp := struct {
		Datasetresourcename string
	}{
		Datasetresourcename: datasetresourcename,
	}
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetresourcename}}/annotations`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb []Annotation
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	ListDashboards - catalog service endpoint
	Returns a list of dashboards.
	Parameters:
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListDashboards(query *ListDashboardsQueryParams, resp ...*http.Response) ([]Dashboard, error) {
	values := util.ParseURLParams(query)
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/catalog/v2beta1/dashboards`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb []Dashboard
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	ListDatasets - catalog service endpoint
	Returns a list of all datasets. Use a filter to return a specific list of datasets.
	Parameters:
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListDatasets(query *ListDatasetsQueryParams, resp ...*http.Response) ([]DatasetGet, error) {
	values := util.ParseURLParams(query)
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/catalog/v2beta1/datasets`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb []DatasetGet
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	ListFields - catalog service endpoint
	Returns a list of all of the fields in the Metadata Catalog.
	Parameters:
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListFields(query *ListFieldsQueryParams, resp ...*http.Response) ([]Field, error) {
	values := util.ParseURLParams(query)
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/catalog/v2beta1/fields`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb []Field
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	ListFieldsForDataset - catalog service endpoint
	Returns the list of fields in the specified dataset.
	Parameters:
		datasetresourcename: The resource name of a dataset. For the default module, the resource name format is datasetName. Otherwise, the resource name format is module.datasetName.
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListFieldsForDataset(datasetresourcename string, query *ListFieldsForDatasetQueryParams, resp ...*http.Response) ([]Field, error) {
	values := util.ParseURLParams(query)
	pp := struct {
		Datasetresourcename string
	}{
		Datasetresourcename: datasetresourcename,
	}
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetresourcename}}/fields`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb []Field
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	ListFieldsForDatasetById - catalog service endpoint
	Returns the set of fields for the dataset with the specified ID.
	Parameters:
		datasetid: ID of a Dataset.
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListFieldsForDatasetById(datasetid string, query *ListFieldsForDatasetByIdQueryParams, resp ...*http.Response) ([]Field, error) {
	values := util.ParseURLParams(query)
	pp := struct {
		Datasetid string
	}{
		Datasetid: datasetid,
	}
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetid}}/fields`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb []Field
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	ListModules - catalog service endpoint
	Returns a list of all modules. Use a filter to return a specific list of modules.
	Parameters:
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListModules(query *ListModulesQueryParams, resp ...*http.Response) ([]Module, error) {
	values := util.ParseURLParams(query)
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/catalog/v2beta1/modules`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb []Module
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	ListRelationships - catalog service endpoint
	Returns a list of all relationships. Use a filter to return a specific list of relationships.
	Parameters:
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListRelationships(query *ListRelationshipsQueryParams, resp ...*http.Response) ([]Relationship, error) {
	values := util.ParseURLParams(query)
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/catalog/v2beta1/relationships`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb []Relationship
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	ListRules - catalog service endpoint
	Returns a list of rules that match a filter, if specified, otherwise returns all rules.
	Parameters:
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListRules(query *ListRulesQueryParams, resp ...*http.Response) ([]Rule, error) {
	values := util.ParseURLParams(query)
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/catalog/v2beta1/rules`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb []Rule
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	ListWorkflowBuilds - catalog service endpoint
	Returns a list of Machine Learning workflow builds.
	Parameters:
		workflowid: ID of a workflow.
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListWorkflowBuilds(workflowid string, query *ListWorkflowBuildsQueryParams, resp ...*http.Response) ([]WorkflowBuild, error) {
	values := util.ParseURLParams(query)
	pp := struct {
		Workflowid string
	}{
		Workflowid: workflowid,
	}
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/catalog/v2beta1/workflows/{{.Workflowid}}/builds`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb []WorkflowBuild
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	ListWorkflowRuns - catalog service endpoint
	Returns a list of Machine Learning workflow runs for specified workflow build ID.
	Parameters:
		workflowid: ID of a workflow.
		workflowbuildid: ID of a workflow build.
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListWorkflowRuns(workflowid string, workflowbuildid string, query *ListWorkflowRunsQueryParams, resp ...*http.Response) ([]WorkflowRun, error) {
	values := util.ParseURLParams(query)
	pp := struct {
		Workflowid      string
		Workflowbuildid string
	}{
		Workflowid:      workflowid,
		Workflowbuildid: workflowbuildid,
	}
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/catalog/v2beta1/workflows/{{.Workflowid}}/builds/{{.Workflowbuildid}}/runs`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb []WorkflowRun
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	ListWorkflows - catalog service endpoint
	Return a list of Machine Learning workflow configurations.
	Parameters:
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListWorkflows(query *ListWorkflowsQueryParams, resp ...*http.Response) ([]Workflow, error) {
	values := util.ParseURLParams(query)
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/catalog/v2beta1/workflows`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb []Workflow
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	UpdateActionByIdForRule - catalog service endpoint
	Modifies the action with the specified ID that is associated with the specified rule resource name.
	Parameters:
		ruleresourcename: The resource name of a rule. For the default module, the resource name format is ruleName. Otherwise, the resource name format is module.ruleName.
		actionid: ID of an Action.
		actionPatch: The fields to update in the specified action.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) UpdateActionByIdForRule(ruleresourcename string, actionid string, actionPatch ActionPatch, resp ...*http.Response) (*Action, error) {
	pp := struct {
		Ruleresourcename string
		Actionid         string
	}{
		Ruleresourcename: ruleresourcename,
		Actionid:         actionid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/rules/{{.Ruleresourcename}}/actions/{{.Actionid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Patch(services.RequestParams{URL: u, Body: actionPatch})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Action
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	UpdateActionByIdForRuleById - catalog service endpoint
	Modifies the action with the specified ID that is associated with the specified rule.
	Parameters:
		ruleid: ID of a Field.
		actionid: ID of an Action.
		actionPatch: The properties to update in the specified action.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) UpdateActionByIdForRuleById(ruleid string, actionid string, actionPatch ActionPatch, resp ...*http.Response) (*Action, error) {
	pp := struct {
		Ruleid   string
		Actionid string
	}{
		Ruleid:   ruleid,
		Actionid: actionid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/rules/{{.Ruleid}}/actions/{{.Actionid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Patch(services.RequestParams{URL: u, Body: actionPatch})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Action
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	UpdateDashboardById - catalog service endpoint
	Modifies the dashboard with the specified ID.
	Parameters:
		dashboardid: ID of a dashboard.
		dashboardPatch: An updated representation of the dashboard to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) UpdateDashboardById(dashboardid string, dashboardPatch DashboardPatch, resp ...*http.Response) (*Dashboard, error) {
	pp := struct {
		Dashboardid string
	}{
		Dashboardid: dashboardid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/dashboards/{{.Dashboardid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Patch(services.RequestParams{URL: u, Body: dashboardPatch})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Dashboard
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	UpdateDashboardByResourceName - catalog service endpoint
	Modifies the dashboard with the specified resource name.
	Parameters:
		dashboardresourcename: The resource name of a dashvboard. The resource name format is module.dashboardname.
		dashboardPatch: An updated representation of the dashboard to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) UpdateDashboardByResourceName(dashboardresourcename string, dashboardPatch DashboardPatch, resp ...*http.Response) error {
	pp := struct {
		Dashboardresourcename string
	}{
		Dashboardresourcename: dashboardresourcename,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/dashboards/{{.Dashboardresourcename}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Patch(services.RequestParams{URL: u, Body: dashboardPatch})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	return err
}

/*
	UpdateDataset - catalog service endpoint
	Modifies the dataset with the specified resource name. For the default module, the resource name format is datasetName. Otherwise, the resource name format is module.datasetName.
	Parameters:
		datasetresourcename: The resource name of a dataset. For the default module, the resource name format is datasetName. Otherwise, the resource name format is module.datasetName.
		datasetPatch: An updated representation of the dataset to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) UpdateDataset(datasetresourcename string, datasetPatch DatasetPatch, resp ...*http.Response) (*Dataset, error) {
	pp := struct {
		Datasetresourcename string
	}{
		Datasetresourcename: datasetresourcename,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetresourcename}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Patch(services.RequestParams{URL: u, Body: datasetPatch})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Dataset
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	UpdateDatasetById - catalog service endpoint
	Modifies the dataset with the specified ID.
	Parameters:
		datasetid: ID of a Dataset.
		datasetPatch: An updated representation of the dataset to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) UpdateDatasetById(datasetid string, datasetPatch DatasetPatch, resp ...*http.Response) (*Dataset, error) {
	pp := struct {
		Datasetid string
	}{
		Datasetid: datasetid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Patch(services.RequestParams{URL: u, Body: datasetPatch})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Dataset
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	UpdateFieldByIdForDataset - catalog service endpoint
	Modifies the field with the specified ID that is part of the specified dataset.
	Parameters:
		datasetresourcename: The resource name of a dataset. For the default module, the resource name format is datasetName. Otherwise, the resource name format is module.datasetName.
		fieldid: ID of a Field.
		fieldPatch: The properties to update in the specified field.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) UpdateFieldByIdForDataset(datasetresourcename string, fieldid string, fieldPatch FieldPatch, resp ...*http.Response) (*Field, error) {
	pp := struct {
		Datasetresourcename string
		Fieldid             string
	}{
		Datasetresourcename: datasetresourcename,
		Fieldid:             fieldid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetresourcename}}/fields/{{.Fieldid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Patch(services.RequestParams{URL: u, Body: fieldPatch})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Field
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	UpdateFieldByIdForDatasetById - catalog service endpoint
	Modifies the field with the specified ID that is part of the specified dataset.
	Parameters:
		datasetid: ID of a Dataset.
		fieldid: ID of a Field.
		fieldPatch: The properties to update in the specified field, or the requesting user lacks catalog.datasets.read permission for them.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) UpdateFieldByIdForDatasetById(datasetid string, fieldid string, fieldPatch FieldPatch, resp ...*http.Response) (*Field, error) {
	pp := struct {
		Datasetid string
		Fieldid   string
	}{
		Datasetid: datasetid,
		Fieldid:   fieldid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/datasets/{{.Datasetid}}/fields/{{.Fieldid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Patch(services.RequestParams{URL: u, Body: fieldPatch})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Field
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	UpdateRelationshipById - catalog service endpoint
	Modifies the relationship with the specified relationship ID.
	Parameters:
		relationshipid: ID of a relationship.
		relationshipPatch: The properties to update in the specified relationship.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) UpdateRelationshipById(relationshipid string, relationshipPatch RelationshipPatch, resp ...*http.Response) (*Relationship, error) {
	pp := struct {
		Relationshipid string
	}{
		Relationshipid: relationshipid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/relationships/{{.Relationshipid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Patch(services.RequestParams{URL: u, Body: relationshipPatch})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Relationship
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	UpdateRule - catalog service endpoint
	Modifies the rule with the specified resource name.
	Parameters:
		ruleresourcename: The resource name of a rule. For the default module, the resource name format is ruleName. Otherwise, the resource name format is module.ruleName.
		rulePatch: The properties to update in the specified rule.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) UpdateRule(ruleresourcename string, rulePatch RulePatch, resp ...*http.Response) (*Rule, error) {
	pp := struct {
		Ruleresourcename string
	}{
		Ruleresourcename: ruleresourcename,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/rules/{{.Ruleresourcename}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Patch(services.RequestParams{URL: u, Body: rulePatch})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Rule
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	UpdateRuleById - catalog service endpoint
	Modifies the rule with the specified rule ID.
	Parameters:
		ruleid: ID of a Field.
		rulePatch: The properties to update in the specified rule.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) UpdateRuleById(ruleid string, rulePatch RulePatch, resp ...*http.Response) (*Rule, error) {
	pp := struct {
		Ruleid string
	}{
		Ruleid: ruleid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/rules/{{.Ruleid}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Patch(services.RequestParams{URL: u, Body: rulePatch})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Rule
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	UpdateWorkflowBuildById - catalog service endpoint
	Modifies the workflow build with the specified workflow build ID.
	Parameters:
		workflowid: ID of a workflow.
		workflowbuildid: ID of a workflow build.
		workflowBuildPatch: An updated representation of the workflow build to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) UpdateWorkflowBuildById(workflowid string, workflowbuildid string, workflowBuildPatch WorkflowBuildPatch, resp ...*http.Response) error {
	pp := struct {
		Workflowid      string
		Workflowbuildid string
	}{
		Workflowid:      workflowid,
		Workflowbuildid: workflowbuildid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/workflows/{{.Workflowid}}/builds/{{.Workflowbuildid}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Patch(services.RequestParams{URL: u, Body: workflowBuildPatch})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	return err
}

/*
	UpdateWorkflowById - catalog service endpoint
	Modifies the workflow with the specified workflow ID.
	Parameters:
		workflowid: ID of a workflow.
		workflowPatch: An updated representation of the workflow to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) UpdateWorkflowById(workflowid string, workflowPatch WorkflowPatch, resp ...*http.Response) error {
	pp := struct {
		Workflowid string
	}{
		Workflowid: workflowid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/workflows/{{.Workflowid}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Patch(services.RequestParams{URL: u, Body: workflowPatch})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	return err
}

/*
	UpdateWorkflowRunById - catalog service endpoint
	Modifies the workflow run with the specified workflow run ID.
	Parameters:
		workflowid: ID of a workflow.
		workflowbuildid: ID of a workflow build.
		workflowrunid: ID of a workflow run.
		workflowRunPatch: An updated representation of the workflow run to be persisted.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) UpdateWorkflowRunById(workflowid string, workflowbuildid string, workflowrunid string, workflowRunPatch WorkflowRunPatch, resp ...*http.Response) error {
	pp := struct {
		Workflowid      string
		Workflowbuildid string
		Workflowrunid   string
	}{
		Workflowid:      workflowid,
		Workflowbuildid: workflowbuildid,
		Workflowrunid:   workflowrunid,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/catalog/v2beta1/workflows/{{.Workflowid}}/builds/{{.Workflowbuildid}}/runs/{{.Workflowrunid}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Patch(services.RequestParams{URL: u, Body: workflowRunPatch})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	return err
}
