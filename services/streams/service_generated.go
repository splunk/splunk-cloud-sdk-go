/*
 * Copyright Â© 2020 Splunk, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"): you may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * Data Stream Processing REST API
 *
 * With the Streams service in Splunk Cloud Services, you can perform create, read, update, and delete (CRUD) operations on your data pipeline.The Streams service in Splunk Cloud Services also has metrics and preview session endpoints and gives you full control over your data pipeline.
 *
 * API version: v2beta1.3 (recommended default)
 * Generated by: OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.
 */

package streams

import (
	"net/http"

	"github.com/splunk/splunk-cloud-sdk-go/services"
	"github.com/splunk/splunk-cloud-sdk-go/util"
)

const serviceCluster = "api"

type Service services.BaseService

// NewService creates a new streams service client from the given Config
func NewService(config *services.Config) (*Service, error) {
	baseClient, err := services.NewClient(config)
	if err != nil {
		return nil, err
	}
	return &Service{Client: baseClient}, nil
}

/*
	ActivatePipeline - Activates an existing pipeline.
	Parameters:
		id: id of the pipeline to activate
		activatePipelineRequest: Request JSON
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ActivatePipeline(id string, activatePipelineRequest ActivatePipelineRequest, resp ...*http.Response) (*Response, error) {
	pp := struct {
		Id string
	}{
		Id: id,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/streams/v2beta1/pipelines/{{.Id}}/activate`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: activatePipelineRequest})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Response
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CompileDSL - Compiles the Streams DSL and returns Streams JSON.
	Parameters:
		dslCompilationRequest: Request JSON
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CompileDSL(dslCompilationRequest DslCompilationRequest, resp ...*http.Response) (*UplPipeline, error) {
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/streams/v2beta1/pipelines/compile-dsl`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: dslCompilationRequest})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb UplPipeline
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CompileSPL - Compiles SPL2 and returns Streams JSON.
	Parameters:
		splCompileRequest: Request JSON
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CompileSPL(splCompileRequest SplCompileRequest, resp ...*http.Response) (*UplPipeline, error) {
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/streams/v2beta1/pipelines/compile-spl`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: splCompileRequest})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb UplPipeline
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CreateConnection - Create a new DSP connection.
	Parameters:
		connectionRequest: Request JSON
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateConnection(connectionRequest ConnectionRequest, resp ...*http.Response) (*ConnectionSaveResponse, error) {
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/streams/v2beta1/connections`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: connectionRequest})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb ConnectionSaveResponse
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CreateGroup - Create a new group function by combining the Streams JSON of two or more functions.
	Parameters:
		groupRequest: Request JSON
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateGroup(groupRequest GroupRequest, resp ...*http.Response) (*GroupResponse, error) {
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/streams/v2beta1/groups`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: groupRequest})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb GroupResponse
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CreatePipeline - Creates a pipeline.
	Parameters:
		pipelineRequest: Request JSON
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreatePipeline(pipelineRequest PipelineRequest, resp ...*http.Response) (*PipelineResponse, error) {
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/streams/v2beta1/pipelines`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: pipelineRequest})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb PipelineResponse
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	CreateTemplate - Creates a template for a tenant.
	Parameters:
		templateRequest: Request JSON
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateTemplate(templateRequest TemplateRequest, resp ...*http.Response) (*TemplateResponse, error) {
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/streams/v2beta1/templates`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: templateRequest})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb TemplateResponse
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	DeactivatePipeline - Deactivates an existing pipeline.
	Parameters:
		id: id of the pipeline to deactivate
		deactivatePipelineRequest: Request JSON
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeactivatePipeline(id string, deactivatePipelineRequest DeactivatePipelineRequest, resp ...*http.Response) (*Response, error) {
	pp := struct {
		Id string
	}{
		Id: id,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/streams/v2beta1/pipelines/{{.Id}}/deactivate`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: deactivatePipelineRequest})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Response
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	DeleteConnection - Delete all versions of a connection by its id.
	Parameters:
		connectionId: ID of the connection
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteConnection(connectionId string, resp ...*http.Response) error {
	pp := struct {
		ConnectionId string
	}{
		ConnectionId: connectionId,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/streams/v2beta1/connections/{{.ConnectionId}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	return err
}

/*
	DeleteGroup - Removes an existing group.
	Parameters:
		groupId: The group function's ID from the function registry
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteGroup(groupId string, resp ...*http.Response) error {
	pp := struct {
		GroupId string
	}{
		GroupId: groupId,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/streams/v2beta1/groups/{{.GroupId}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	return err
}

/*
	DeletePipeline - Removes a pipeline.
	Parameters:
		id: id of the pipeline to delete
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeletePipeline(id string, resp ...*http.Response) (*PipelineDeleteResponse, error) {
	pp := struct {
		Id string
	}{
		Id: id,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/streams/v2beta1/pipelines/{{.Id}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb PipelineDeleteResponse
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	DeleteTemplate - Removes a template with a specific ID.
	Parameters:
		templateId: ID of the template to delete
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteTemplate(templateId string, resp ...*http.Response) error {
	pp := struct {
		TemplateId string
	}{
		TemplateId: templateId,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/streams/v2beta1/templates/{{.TemplateId}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	return err
}

/*
	ExpandGroup - Creates and returns the expanded version of a group.
	Parameters:
		groupId: The group function's ID from the function registry
		groupExpandRequest: Request JSON
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ExpandGroup(groupId string, groupExpandRequest GroupExpandRequest, resp ...*http.Response) (*UplPipeline, error) {
	pp := struct {
		GroupId string
	}{
		GroupId: groupId,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/streams/v2beta1/groups/{{.GroupId}}/expand`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: groupExpandRequest})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb UplPipeline
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	ExpandPipeline - Returns the entire Streams JSON, including the expanded Streams JSON of any group functions in the pipeline.
	Parameters:
		uplPipeline: Request JSON
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ExpandPipeline(uplPipeline UplPipeline, resp ...*http.Response) (*UplPipeline, error) {
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/streams/v2beta1/pipelines/expand`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: uplPipeline})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb UplPipeline
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetGroup - Returns the full Streams JSON of a group.
	Parameters:
		groupId: The group function's ID from the function registry
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetGroup(groupId string, resp ...*http.Response) (*GroupResponse, error) {
	pp := struct {
		GroupId string
	}{
		GroupId: groupId,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/streams/v2beta1/groups/{{.GroupId}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb GroupResponse
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetInputSchema - Returns the input schema for a function in a pipeline.
	Parameters:
		getInputSchemaRequest: Input Schema Request
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetInputSchema(getInputSchemaRequest GetInputSchemaRequest, resp ...*http.Response) (*UplType, error) {
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/streams/v2beta1/pipelines/input-schema`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: getInputSchemaRequest})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb UplType
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetOutputSchema - Returns the output schema for a specified function in a pipeline. If no function ID is  specified, the request returns the output schema for all functions in a pipeline.
	Parameters:
		getOutputSchemaRequest: Output Schema Request
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetOutputSchema(getOutputSchemaRequest GetOutputSchemaRequest, resp ...*http.Response) (map[string]UplType, error) {
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/streams/v2beta1/pipelines/output-schema`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: getOutputSchemaRequest})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb map[string]UplType
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	GetPipeline - Returns an individual pipeline by version.
	Parameters:
		id: id of the pipeline to get
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetPipeline(id string, query *GetPipelineQueryParams, resp ...*http.Response) (*PipelineResponse, error) {
	values := util.ParseURLParams(query)
	pp := struct {
		Id string
	}{
		Id: id,
	}
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/streams/v2beta1/pipelines/{{.Id}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb PipelineResponse
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetPipelineLatestMetrics - Returns the latest metrics for a single pipeline.
	Parameters:
		id: ID of the pipeline to get metrics for
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetPipelineLatestMetrics(id string, resp ...*http.Response) (*MetricsResponse, error) {
	pp := struct {
		Id string
	}{
		Id: id,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/streams/v2beta1/pipelines/{{.Id}}/metrics/latest`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb MetricsResponse
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetPipelinesStatus - Returns the status of pipelines from the underlying streaming system.
	Parameters:
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetPipelinesStatus(query *GetPipelinesStatusQueryParams, resp ...*http.Response) (*PaginatedResponseOfPipelineJobStatus, error) {
	values := util.ParseURLParams(query)
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/streams/v2beta1/pipelines/status`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb PaginatedResponseOfPipelineJobStatus
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetPreviewData - Returns the preview data for a session.
	Parameters:
		previewSessionId: ID of the preview session
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetPreviewData(previewSessionId int64, resp ...*http.Response) (*PreviewData, error) {
	pp := struct {
		PreviewSessionId int64
	}{
		PreviewSessionId: previewSessionId,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/streams/v2beta1/preview-data/{{.PreviewSessionId}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb PreviewData
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetPreviewSession - Returns information from a preview session.
	Parameters:
		previewSessionId: ID of the preview session
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetPreviewSession(previewSessionId int64, resp ...*http.Response) (*PreviewState, error) {
	pp := struct {
		PreviewSessionId int64
	}{
		PreviewSessionId: previewSessionId,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/streams/v2beta1/preview-session/{{.PreviewSessionId}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb PreviewState
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetPreviewSessionLatestMetrics - Returns the latest metrics for a preview session.
	Parameters:
		previewSessionId: ID of the preview session
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetPreviewSessionLatestMetrics(previewSessionId int64, resp ...*http.Response) (*MetricsResponse, error) {
	pp := struct {
		PreviewSessionId int64
	}{
		PreviewSessionId: previewSessionId,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/streams/v2beta1/preview-session/{{.PreviewSessionId}}/metrics/latest`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb MetricsResponse
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetRegistry - Returns all functions in JSON format.
	Parameters:
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetRegistry(query *GetRegistryQueryParams, resp ...*http.Response) (*UplRegistry, error) {
	values := util.ParseURLParams(query)
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/streams/v2beta1/pipelines/registry`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb UplRegistry
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetTemplate - Returns an individual template by version.
	Parameters:
		templateId: ID of the template
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetTemplate(templateId string, query *GetTemplateQueryParams, resp ...*http.Response) (*TemplateResponse, error) {
	values := util.ParseURLParams(query)
	pp := struct {
		TemplateId string
	}{
		TemplateId: templateId,
	}
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/streams/v2beta1/templates/{{.TemplateId}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb TemplateResponse
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	ListConnections - Returns a list of connections (latest versions only) by tenant ID.
	Parameters:
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListConnections(query *ListConnectionsQueryParams, resp ...*http.Response) (*PaginatedResponseOfConnectionResponse, error) {
	values := util.ParseURLParams(query)
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/streams/v2beta1/connections`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb PaginatedResponseOfConnectionResponse
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	ListConnectors - Returns a list of the available connectors.
	Parameters:
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListConnectors(resp ...*http.Response) (*PaginatedResponseOfConnectorResponse, error) {
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/streams/v2beta1/connectors`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb PaginatedResponseOfConnectorResponse
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	ListPipelines - Returns all pipelines.
	Parameters:
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListPipelines(query *ListPipelinesQueryParams, resp ...*http.Response) (*PaginatedResponseOfPipelineResponse, error) {
	values := util.ParseURLParams(query)
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/streams/v2beta1/pipelines`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb PaginatedResponseOfPipelineResponse
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	ListTemplates - Returns a list of all templates.
	Parameters:
		query: a struct pointer of valid query parameters for the endpoint, nil to send no query parameters
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListTemplates(query *ListTemplatesQueryParams, resp ...*http.Response) (*PaginatedResponseOfTemplateResponse, error) {
	values := util.ParseURLParams(query)
	u, err := s.Client.BuildURLFromPathParams(values, serviceCluster, `/streams/v2beta1/templates`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb PaginatedResponseOfTemplateResponse
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	MergePipelines - Combines two Streams JSON programs.
	Parameters:
		pipelinesMergeRequest: Request JSON
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) MergePipelines(pipelinesMergeRequest PipelinesMergeRequest, resp ...*http.Response) (*UplPipeline, error) {
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/streams/v2beta1/pipelines/merge`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: pipelinesMergeRequest})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb UplPipeline
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	PutConnection - Modifies an existing DSP connection.
	Parameters:
		connectionId: ID of the connection
		connectionPutRequest: Request JSON
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) PutConnection(connectionId string, connectionPutRequest ConnectionPutRequest, resp ...*http.Response) (*ConnectionSaveResponse, error) {
	pp := struct {
		ConnectionId string
	}{
		ConnectionId: connectionId,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/streams/v2beta1/connections/{{.ConnectionId}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Put(services.RequestParams{URL: u, Body: connectionPutRequest})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb ConnectionSaveResponse
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	PutGroup - Update a group function combining the Streams JSON of two or more functions.
	Parameters:
		groupId: The group function's ID from the function registry
		groupPutRequest: Request JSON
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) PutGroup(groupId string, groupPutRequest GroupPutRequest, resp ...*http.Response) (*GroupResponse, error) {
	pp := struct {
		GroupId string
	}{
		GroupId: groupId,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/streams/v2beta1/groups/{{.GroupId}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Put(services.RequestParams{URL: u, Body: groupPutRequest})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb GroupResponse
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	PutTemplate - Updates an existing template.
	Parameters:
		templateId: ID of the template
		templatePutRequest: Request JSON
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) PutTemplate(templateId string, templatePutRequest TemplatePutRequest, resp ...*http.Response) (*TemplateResponse, error) {
	pp := struct {
		TemplateId string
	}{
		TemplateId: templateId,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/streams/v2beta1/templates/{{.TemplateId}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Put(services.RequestParams{URL: u, Body: templatePutRequest})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb TemplateResponse
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	ReactivatePipeline - Reactivate a pipeline
	Parameters:
		id: Pipeline UUID to reactivate
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ReactivatePipeline(id string, resp ...*http.Response) (*PipelineReactivateResponse, error) {
	pp := struct {
		Id string
	}{
		Id: id,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/streams/v2beta1/pipelines/{{.Id}}/reactivate`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb PipelineReactivateResponse
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	StartPreview - Creates a preview session for a pipeline.
	Parameters:
		previewSessionStartRequest: Parameters to start a new Preview session
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) StartPreview(previewSessionStartRequest PreviewSessionStartRequest, resp ...*http.Response) (*PreviewStartResponse, error) {
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/streams/v2beta1/preview-session`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: previewSessionStartRequest})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb PreviewStartResponse
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	StopPreview - Stops a preview session.
	Parameters:
		previewSessionId: ID of the preview session
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) StopPreview(previewSessionId int64, resp ...*http.Response) (*string, error) {
	pp := struct {
		PreviewSessionId int64
	}{
		PreviewSessionId: previewSessionId,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/streams/v2beta1/preview-session/{{.PreviewSessionId}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb string
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	UpdateConnection - Partially modifies an existing DSP connection.
	Parameters:
		connectionId: ID of the connection
		connectionPatchRequest: Request JSON
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) UpdateConnection(connectionId string, connectionPatchRequest ConnectionPatchRequest, resp ...*http.Response) (*ConnectionSaveResponse, error) {
	pp := struct {
		ConnectionId string
	}{
		ConnectionId: connectionId,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/streams/v2beta1/connections/{{.ConnectionId}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Patch(services.RequestParams{URL: u, Body: connectionPatchRequest})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb ConnectionSaveResponse
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	UpdateGroup - Modify a group function by combining the Streams JSON of two or more functions.
	Parameters:
		groupId: The group function's ID from the function registry
		groupPatchRequest: Request JSON
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) UpdateGroup(groupId string, groupPatchRequest GroupPatchRequest, resp ...*http.Response) (*GroupResponse, error) {
	pp := struct {
		GroupId string
	}{
		GroupId: groupId,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/streams/v2beta1/groups/{{.GroupId}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Patch(services.RequestParams{URL: u, Body: groupPatchRequest})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb GroupResponse
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	UpdatePipeline - Partially modifies an existing pipeline.
	Parameters:
		id: id of the pipeline to update
		pipelinePatchRequest: Request JSON
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) UpdatePipeline(id string, pipelinePatchRequest PipelinePatchRequest, resp ...*http.Response) (*PipelineResponse, error) {
	pp := struct {
		Id string
	}{
		Id: id,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/streams/v2beta1/pipelines/{{.Id}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Patch(services.RequestParams{URL: u, Body: pipelinePatchRequest})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb PipelineResponse
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	UpdateTemplate - Partially modifies an existing template.
	Parameters:
		templateId: ID of the template
		templatePatchRequest: Request JSON
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) UpdateTemplate(templateId string, templatePatchRequest TemplatePatchRequest, resp ...*http.Response) (*TemplateResponse, error) {
	pp := struct {
		TemplateId string
	}{
		TemplateId: templateId,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/streams/v2beta1/templates/{{.TemplateId}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Patch(services.RequestParams{URL: u, Body: templatePatchRequest})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb TemplateResponse
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	ValidatePipeline - Verifies whether the Streams JSON is valid.
	Parameters:
		validateRequest: JSON UPL to validate
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ValidatePipeline(validateRequest ValidateRequest, resp ...*http.Response) (*ValidateResponse, error) {
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/streams/v2beta1/pipelines/validate`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: validateRequest})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb ValidateResponse
	err = util.ParseResponse(&rb, response)
	return &rb, err
}
