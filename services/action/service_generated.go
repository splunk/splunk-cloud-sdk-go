/*
 * Copyright Â© 2020 Splunk, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"): you may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * Action Service
 *
 * With the Action service in Splunk Cloud Services, you can receive incoming trigger events and use pre-defined action templates to turn these events into meaningful actions.
 *
 * API version: v1beta2.12 (recommended default)
 * Generated by: OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.
 */

package action

import (
	"net/http"

	"github.com/splunk/splunk-cloud-sdk-go/services"
	"github.com/splunk/splunk-cloud-sdk-go/util"
)

const serviceCluster = "api"

type Service services.BaseService

// NewService creates a new action service client from the given Config
func NewService(iClient services.IClient) *Service {
	return &Service{Client: iClient}
}

/*
	CreateAction - Creates an action template.
	Parameters:
		action: The action template to create.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) CreateAction(action Action, resp ...*http.Response) (*Action, error) {
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/action/v1beta2/actions`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: action})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Action
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	DeleteAction - Removes an action template.
	Parameters:
		actionName: The name of the action as one or more identifier strings separated by periods. Each identifier string consists of lowercase letters, digits, and underscores, and cannot start with a digit.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) DeleteAction(actionName string, resp ...*http.Response) error {
	pp := struct {
		ActionName string
	}{
		ActionName: actionName,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/action/v1beta2/actions/{{.ActionName}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Delete(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	return err
}

/*
	GetAction - Returns a specific action template.
	Parameters:
		actionName: The name of the action as one or more identifier strings separated by periods. Each identifier string consists of lowercase letters, digits, and underscores, and cannot start with a digit.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetAction(actionName string, resp ...*http.Response) (*Action, error) {
	pp := struct {
		ActionName string
	}{
		ActionName: actionName,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/action/v1beta2/actions/{{.ActionName}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Action
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetActionStatus - Returns the status of an action that was invoked. The status is available for 4 days after the last status change.
	Parameters:
		actionName: The name of the action as one or more identifier strings separated by periods. Each identifier string consists of lowercase letters, digits, and underscores, and cannot start with a digit.
		statusId: The ID of the action status.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetActionStatus(actionName string, statusId string, resp ...*http.Response) (*ActionResult, error) {
	pp := struct {
		ActionName string
		StatusId   string
	}{
		ActionName: actionName,
		StatusId:   statusId,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/action/v1beta2/actions/{{.ActionName}}/status/{{.StatusId}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb ActionResult
	err = util.ParseResponse(&rb, response)
	return &rb, err
}

/*
	GetActionStatusDetails - Returns the status details of the invoked email action. The status is available for 4 days after the last status change.
	Parameters:
		actionName: The name of the action as one or more identifier strings separated by periods. Each identifier string consists of lowercase letters, digits, and underscores, and cannot start with a digit.
		statusId: The ID of the action status.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetActionStatusDetails(actionName string, statusId string, resp ...*http.Response) ([]ActionResultEmailDetail, error) {
	pp := struct {
		ActionName string
		StatusId   string
	}{
		ActionName: actionName,
		StatusId:   statusId,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/action/v1beta2/actions/{{.ActionName}}/status/{{.StatusId}}/details`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb []ActionResultEmailDetail
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	GetPublicWebhookKeys - Returns an array of one or two webhook keys. The first key is active. The second key, if present, is expired.
	Parameters:
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) GetPublicWebhookKeys(resp ...*http.Response) ([]PublicWebhookKey, error) {
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/system/action/v1beta2/webhook/keys`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb []PublicWebhookKey
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	ListActions - Returns the list of action templates.
	Parameters:
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) ListActions(resp ...*http.Response) ([]Action, error) {
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/action/v1beta2/actions`, nil)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Get(services.RequestParams{URL: u})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb []Action
	err = util.ParseResponse(&rb, response)
	return rb, err
}

/*
	TriggerAction - Invokes an action.
	Parameters:
		actionName: The name of the action as one or more identifier strings separated by periods. Each identifier string consists of lowercase letters, digits, and underscores, and cannot start with a digit.
		triggerEvent: The action payload, which should include values for any templated fields.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) TriggerAction(actionName string, triggerEvent TriggerEvent, resp ...*http.Response) error {
	pp := struct {
		ActionName string
	}{
		ActionName: actionName,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/action/v1beta2/actions/{{.ActionName}}`, pp)
	if err != nil {
		return err
	}
	response, err := s.Client.Post(services.RequestParams{URL: u, Body: triggerEvent})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	return err
}

/*
	UpdateAction - Modifies an action template.
	Parameters:
		actionName: The name of the action as one or more identifier strings separated by periods. Each identifier string consists of lowercase letters, digits, and underscores, and cannot start with a digit.
		actionMutable: Updates to the action template.
		resp: an optional pointer to a http.Response to be populated by this method. NOTE: only the first resp pointer will be used if multiple are provided
*/
func (s *Service) UpdateAction(actionName string, actionMutable ActionMutable, resp ...*http.Response) (*Action, error) {
	pp := struct {
		ActionName string
	}{
		ActionName: actionName,
	}
	u, err := s.Client.BuildURLFromPathParams(nil, serviceCluster, `/action/v1beta2/actions/{{.ActionName}}`, pp)
	if err != nil {
		return nil, err
	}
	response, err := s.Client.Patch(services.RequestParams{URL: u, Body: actionMutable})
	if response != nil {
		defer response.Body.Close()

		// populate input *http.Response if provided
		if len(resp) > 0 && resp[0] != nil {
			*resp[0] = *response
		}
	}
	if err != nil {
		return nil, err
	}
	var rb Action
	err = util.ParseResponse(&rb, response)
	return &rb, err
}
